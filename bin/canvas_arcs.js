// Generated by Haxe 4.3.0-rc.1+
(function ($global) { "use strict";
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = "HxOverrides";
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
Math.__name__ = "Math";
var Std = function() { };
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = "StringTools";
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var XmlType = {};
XmlType.toString = function(this1) {
	switch(this1) {
	case 0:
		return "Element";
	case 1:
		return "PCData";
	case 2:
		return "CData";
	case 3:
		return "Comment";
	case 4:
		return "DocType";
	case 5:
		return "ProcessingInstruction";
	case 6:
		return "Document";
	}
};
var Xml = function(nodeType) {
	this.nodeType = nodeType;
	this.children = [];
	this.attributeMap = new haxe_ds_StringMap();
};
Xml.__name__ = "Xml";
Xml.parse = function(str) {
	return haxe_xml_Parser.parse(str);
};
Xml.createElement = function(name) {
	var xml = new Xml(Xml.Element);
	if(xml.nodeType != Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeName = name;
	return xml;
};
Xml.createPCData = function(data) {
	var xml = new Xml(Xml.PCData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createCData = function(data) {
	var xml = new Xml(Xml.CData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createComment = function(data) {
	var xml = new Xml(Xml.Comment);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocType = function(data) {
	var xml = new Xml(Xml.DocType);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createProcessingInstruction = function(data) {
	var xml = new Xml(Xml.ProcessingInstruction);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocument = function() {
	return new Xml(Xml.Document);
};
Xml.prototype = {
	get: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	,set: function(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	,exists: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	,attributes: function() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.attributeMap.h);
	}
	,elements: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		var ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	,firstElement: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	,addChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	,removeChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	,toString: function() {
		return haxe_xml_Printer.print(this);
	}
	,__class__: Xml
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	__class__: haxe_ValueException
});
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_xml_XmlParserException = function(message,xml,position) {
	this.xml = xml;
	this.message = message;
	this.position = position;
	this.lineNumber = 1;
	this.positionAtLine = 0;
	var _g = 0;
	var _g1 = position;
	while(_g < _g1) {
		var i = _g++;
		var c = xml.charCodeAt(i);
		if(c == 10) {
			this.lineNumber++;
			this.positionAtLine = 0;
		} else if(c != 13) {
			this.positionAtLine++;
		}
	}
};
haxe_xml_XmlParserException.__name__ = "haxe.xml.XmlParserException";
haxe_xml_XmlParserException.prototype = {
	toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__ + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
	,__class__: haxe_xml_XmlParserException
};
var haxe_xml_Parser = function() { };
haxe_xml_Parser.__name__ = "haxe.xml.Parser";
haxe_xml_Parser.parse = function(str,strict) {
	if(strict == null) {
		strict = false;
	}
	var doc = Xml.createDocument();
	haxe_xml_Parser.doParse(str,strict,0,doc);
	return doc;
};
haxe_xml_Parser.doParse = function(str,strict,p,parent) {
	if(p == null) {
		p = 0;
	}
	var xml = null;
	var state = 1;
	var next = 1;
	var aname = null;
	var start = 0;
	var nsubs = 0;
	var nbrackets = 0;
	var buf = new StringBuf();
	var escapeNext = 1;
	var attrValQuote = -1;
	while(p < str.length) {
		var c = str.charCodeAt(p);
		switch(state) {
		case 0:
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				state = next;
				continue;
			}
			break;
		case 1:
			if(c == 60) {
				state = 0;
				next = 2;
			} else {
				start = p;
				state = 13;
				continue;
			}
			break;
		case 2:
			switch(c) {
			case 33:
				if(str.charCodeAt(p + 1) == 91) {
					p += 2;
					if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
					}
					p += 5;
					state = 17;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
					if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
					}
					p += 8;
					state = 16;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!--",str,p));
				} else {
					p += 2;
					state = 15;
					start = p + 1;
				}
				break;
			case 47:
				if(parent == null) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				start = p + 1;
				state = 0;
				next = 10;
				break;
			case 63:
				state = 14;
				start = p;
				break;
			default:
				state = 3;
				start = p;
				continue;
			}
			break;
		case 3:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(p == start) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
				parent.addChild(xml);
				++nsubs;
				state = 0;
				next = 4;
				continue;
			}
			break;
		case 4:
			switch(c) {
			case 47:
				state = 11;
				break;
			case 62:
				state = 9;
				break;
			default:
				state = 5;
				start = p;
				continue;
			}
			break;
		case 5:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected attribute name",str,p));
				}
				var tmp = HxOverrides.substr(str,start,p - start);
				aname = tmp;
				if(xml.exists(aname)) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Duplicate attribute [" + aname + "]",str,p));
				}
				state = 0;
				next = 6;
				continue;
			}
			break;
		case 6:
			if(c == 61) {
				state = 0;
				next = 7;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected =",str,p));
			}
			break;
		case 7:
			switch(c) {
			case 34:case 39:
				buf = new StringBuf();
				state = 8;
				start = p + 1;
				attrValQuote = c;
				break;
			default:
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected \"",str,p));
			}
			break;
		case 8:
			switch(c) {
			case 38:
				var len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				state = 18;
				escapeNext = 8;
				start = p + 1;
				break;
			case 60:case 62:
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
				} else if(c == attrValQuote) {
					var len1 = p - start;
					buf.b += len1 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len1);
					var val = buf.b;
					buf = new StringBuf();
					xml.set(aname,val);
					state = 0;
					next = 4;
				}
				break;
			default:
				if(c == attrValQuote) {
					var len2 = p - start;
					buf.b += len2 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len2);
					var val1 = buf.b;
					buf = new StringBuf();
					xml.set(aname,val1);
					state = 0;
					next = 4;
				}
			}
			break;
		case 9:
			p = haxe_xml_Parser.doParse(str,strict,p,xml);
			start = p;
			state = 1;
			break;
		case 10:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				var v = HxOverrides.substr(str,start,p - start);
				if(parent == null || parent.nodeType != 0) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected </" + v + ">, tag is not open",str,p));
				}
				if(parent.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
				}
				if(v != parent.nodeName) {
					if(parent.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
					}
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
				}
				state = 0;
				next = 12;
				continue;
			}
			break;
		case 11:
			if(c == 62) {
				state = 1;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 12:
			if(c == 62) {
				if(nsubs == 0) {
					parent.addChild(Xml.createPCData(""));
				}
				return p;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 13:
			if(c == 60) {
				var len3 = p - start;
				buf.b += len3 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len3);
				var child = Xml.createPCData(buf.b);
				buf = new StringBuf();
				parent.addChild(child);
				++nsubs;
				state = 0;
				next = 2;
			} else if(c == 38) {
				var len4 = p - start;
				buf.b += len4 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len4);
				state = 18;
				escapeNext = 13;
				start = p + 1;
			}
			break;
		case 14:
			if(c == 63 && str.charCodeAt(p + 1) == 62) {
				++p;
				var str1 = HxOverrides.substr(str,start + 1,p - start - 2);
				parent.addChild(Xml.createProcessingInstruction(str1));
				++nsubs;
				state = 1;
			}
			break;
		case 15:
			if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
				parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 16:
			if(c == 91) {
				++nbrackets;
			} else if(c == 93) {
				--nbrackets;
			} else if(c == 62 && nbrackets == 0) {
				parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				state = 1;
			}
			break;
		case 17:
			if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
				var child1 = Xml.createCData(HxOverrides.substr(str,start,p - start));
				parent.addChild(child1);
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 18:
			if(c == 59) {
				var s = HxOverrides.substr(str,start,p - start);
				if(s.charCodeAt(0) == 35) {
					var c1 = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
					buf.b += String.fromCodePoint(c1);
				} else if(!Object.prototype.hasOwnProperty.call(haxe_xml_Parser.escapes.h,s)) {
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
					}
					buf.b += Std.string("&" + s + ";");
				} else {
					buf.b += Std.string(haxe_xml_Parser.escapes.h[s]);
				}
				start = p + 1;
				state = escapeNext;
			} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCodePoint(c),str,p));
				}
				buf.b += String.fromCodePoint(38);
				var len5 = p - start;
				buf.b += len5 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len5);
				--p;
				start = p + 1;
				state = escapeNext;
			}
			break;
		}
		++p;
	}
	if(state == 1) {
		start = p;
		state = 13;
	}
	if(state == 13) {
		if(parent.nodeType == 0) {
			if(parent.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
			}
			throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unclosed node <" + parent.nodeName + ">",str,p));
		}
		if(p != start || nsubs == 0) {
			var len = p - start;
			buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
			parent.addChild(Xml.createPCData(buf.b));
			++nsubs;
		}
		return p;
	}
	if(!strict && state == 18 && escapeNext == 13) {
		buf.b += String.fromCodePoint(38);
		var len = p - start;
		buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
		parent.addChild(Xml.createPCData(buf.b));
		++nsubs;
		return p;
	}
	throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected end",str,p));
};
var haxe_xml_Printer = function(pretty) {
	this.output = new StringBuf();
	this.pretty = pretty;
};
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
haxe_xml_Printer.print = function(xml,pretty) {
	if(pretty == null) {
		pretty = false;
	}
	var printer = new haxe_xml_Printer(pretty);
	printer.writeNode(xml,"");
	return printer.output.b;
};
haxe_xml_Printer.prototype = {
	writeNode: function(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			var attribute = value.attributes();
			while(attribute.hasNext()) {
				var attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				var input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				var _g_current = 0;
				var _g_array = value.children;
				while(_g_current < _g_array.length) {
					var child = _g_array[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				var input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var commentContent = value.nodeValue;
			var _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			var input = StringTools.trim(commentContent);
			this.output.b += Std.string(input);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var _g_current = 0;
			var _g_array = value.children;
			while(_g_current < _g_array.length) {
				var child = _g_array[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	,hasChildren: function(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		var _g_current = 0;
		var _g_array = value.children;
		while(_g_current < _g_array.length) {
			var child = _g_array[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,__class__: haxe_xml_Printer
};
var htmlHelper_canvas_CanvasSetup = function() {
	this.factor = 4.;
	this.divertTrace = new htmlHelper_tools_DivertTrace();
	var e = null;
	var this1;
	if(e == null) {
		var canvas = window.document.createElement("canvas");
		var dom = canvas;
		var style = dom.style;
		style.paddingLeft = "0px";
		style.paddingTop = "0px";
		style.left = "0px";
		style.top = "0px";
		style.position = "absolute";
		this1 = canvas;
	} else {
		this1 = e;
	}
	this.canvasWrapper = this1;
	this.canvasWrapper.width = 1024;
	this.canvasWrapper.height = 768;
	var dom = this.canvasWrapper;
	var style = dom.style;
	style.background = "black";
	window.document.body.appendChild(this.canvasWrapper);
	var this1 = new htmlHelper_canvas_CanvasPlus(this.canvasWrapper.getContext("2d",null),10,10);
	this1.me.lineWidth = 1;
	var tmp = StringTools.hex(16744272,6);
	this1.me.strokeStyle = "#" + tmp;
	this.surface = this1;
	this.overSampleCanvas();
};
htmlHelper_canvas_CanvasSetup.__name__ = "htmlHelper.canvas.CanvasSetup";
htmlHelper_canvas_CanvasSetup.prototype = {
	overSampleCanvas: function() {
		var ctx = this.surface.me;
		var canvas = this.canvasWrapper;
		var width = canvas.width;
		var height = canvas.height;
		canvas.width = 0 | (width * this.factor | 0);
		canvas.height = 0 | (height * this.factor | 0);
		var dom = this.canvasWrapper;
		var style = dom.style;
		style.width = width + "px";
		style.height = height + "px";
		ctx.scale(this.factor,this.factor);
	}
	,__class__: htmlHelper_canvas_CanvasSetup
};
var htmlHelper_canvas_CanvasPlus = function(me,x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.y = 0.;
	this.x = 0.;
	this.x = x;
	this.y = y;
	this.me = me;
};
htmlHelper_canvas_CanvasPlus.__name__ = "htmlHelper.canvas.CanvasPlus";
htmlHelper_canvas_CanvasPlus.prototype = {
	__class__: htmlHelper_canvas_CanvasPlus
};
var htmlHelper_tools_DivertTrace = function(left,d) {
	if(left == null) {
		left = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	this.divertTrace(left,d);
};
htmlHelper_tools_DivertTrace.__name__ = "htmlHelper.tools.DivertTrace";
htmlHelper_tools_DivertTrace.prototype = {
	divertTrace: function(left,d) {
		if(d == null) {
			var doc = window.document;
			this.traceDiv = doc.createElement("div");
			doc.body.appendChild(this.traceDiv);
			var dom = this.traceDiv;
			var style = dom.style;
			style.position = "absolute";
			style.top = "0px";
			style.left = (left == null ? "null" : "" + left) + "px";
			style.height = "500px";
			style.width = "500px";
			style.zIndex = "99";
			style.overflow = "auto";
		} else {
			this.traceDiv = d;
		}
		haxe_Log.trace = $bind(this,this.myTrace);
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
	,__class__: htmlHelper_tools_DivertTrace
};
var js_Boot = function() { };
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var pixelimageXY_ImageStruct = function(width,height,image) {
	this.useMask = false;
	this.useVirtualPos = false;
	this.virtualY = 0;
	this.virtualX = 0;
	this.transparent = false;
	this.width = width;
	this.height = height;
	this.image = image;
	this.isLittle = pixelimageXY_Endian_isLittleEndian;
	this.transparent = false;
};
pixelimageXY_ImageStruct.__name__ = "pixelimageXY.ImageStruct";
pixelimageXY_ImageStruct.prototype = {
	__class__: pixelimageXY_ImageStruct
};
var pixelimageXY_algo_IhitObj = function() { };
pixelimageXY_algo_IhitObj.__name__ = "pixelimageXY.algo.IhitObj";
pixelimageXY_algo_IhitObj.__isInterface__ = true;
var pixelimageXY_algo_HitQuad = function(ax,ay,bx,by,cx,cy,dx,dy,preCalculated) {
	if(preCalculated == null) {
		preCalculated = true;
	}
	this.ax = ax;
	this.ay = ay;
	this.bx = bx;
	this.by = by;
	this.cx = cx;
	this.cy = cy;
	this.dx = dx;
	this.dy = dy;
	if(preCalculated) {
		this.triABD = new pixelimageXY_algo_HitTri(this.ax,this.ay,this.bx,this.by,this.dx,this.dy,true);
		this.triBCD = new pixelimageXY_algo_HitTri(this.bx,this.by,this.cx,this.cy,this.dx,this.dy,true);
		var a = this.ax;
		var b = this.bx;
		var c = this.cx;
		var d = this.dx;
		var min = Math.floor(a);
		var max = Math.ceil(a);
		if(b < min) {
			min = Math.floor(b);
		} else if(b > max) {
			max = Math.ceil(b);
		}
		if(c < min) {
			min = Math.floor(c);
		} else if(c > max) {
			max = Math.ceil(c);
		}
		if(d < min) {
			min = Math.floor(d);
		} else if(d > max) {
			max = Math.ceil(d);
		}
		var ii_min = min;
		var ii_max = max;
		var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
		this.xIter4 = this1;
		var a = this.ay;
		var b = this.by;
		var c = this.cy;
		var d = this.dy;
		var min = Math.floor(a);
		var max = Math.ceil(a);
		if(b < min) {
			min = Math.floor(b);
		} else if(b > max) {
			max = Math.ceil(b);
		}
		if(c < min) {
			min = Math.floor(c);
		} else if(c > max) {
			max = Math.ceil(c);
		}
		if(d < min) {
			min = Math.floor(d);
		} else if(d > max) {
			max = Math.ceil(d);
		}
		var ii_min = min;
		var ii_max = max;
		var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
		this.yIter4 = this1;
	}
};
pixelimageXY_algo_HitQuad.__name__ = "pixelimageXY.algo.HitQuad";
pixelimageXY_algo_HitQuad.__interfaces__ = [pixelimageXY_algo_IhitObj];
pixelimageXY_algo_HitQuad.prototype = {
	__class__: pixelimageXY_algo_HitQuad
};
var pixelimageXY_algo_HitTri = function(ax,ay,bx,by,cx,cy,preCalculated) {
	if(preCalculated == null) {
		preCalculated = true;
	}
	this.undoImage = null;
	var adjustWinding = ax * by - bx * ay + (bx * cy - cx * by) + (cx * ay - ax * cy) > 0;
	if(!adjustWinding) {
		var bx_ = bx;
		var by_ = by;
		bx = cx;
		by = cy;
		cx = bx_;
		cy = by_;
	}
	this.ax = ax;
	this.ay = ay;
	this.bx = bx;
	this.by = by;
	this.cx = cx;
	this.cy = cy;
	this.preCalculated = preCalculated;
	if(preCalculated) {
		this.s0 = this.ay * this.cx - this.ax * this.cy;
		this.sx = this.cy - this.ay;
		this.sy = this.ax - this.cx;
		this.t0 = this.ax * this.by - this.ay * this.bx;
		this.tx = this.ay - this.by;
		this.ty = this.bx - this.ax;
		this.A = -this.by * this.cx + this.ay * (-this.bx + this.cx) + this.ax * (this.by - this.cy) + this.bx * this.cy;
		var a = this.ax;
		var b = this.bx;
		var c = this.cx;
		var tmp;
		if(a > b) {
			if(a > c) {
				var ii_min = b > c ? Math.floor(c) : Math.floor(b);
				var ii_max = Math.ceil(a);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			} else {
				var ii_min = Math.floor(b);
				var ii_max = Math.ceil(c);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			}
		} else if(b > c) {
			var ii_min = a > c ? Math.floor(c) : Math.ceil(a);
			var ii_max = Math.ceil(b);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		} else {
			var ii_min = Math.floor(a);
			var ii_max = Math.ceil(c);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		}
		this.xIter3 = tmp;
		var a = this.ay;
		var b = this.by;
		var c = this.cy;
		var tmp;
		if(a > b) {
			if(a > c) {
				var ii_min = b > c ? Math.floor(c) : Math.floor(b);
				var ii_max = Math.ceil(a);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			} else {
				var ii_min = Math.floor(b);
				var ii_max = Math.ceil(c);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				tmp = this1;
			}
		} else if(b > c) {
			var ii_min = a > c ? Math.floor(c) : Math.ceil(a);
			var ii_max = Math.ceil(b);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		} else {
			var ii_min = Math.floor(a);
			var ii_max = Math.ceil(c);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			tmp = this1;
		}
		this.yIter3 = tmp;
	}
};
pixelimageXY_algo_HitTri.__name__ = "pixelimageXY.algo.HitTri";
pixelimageXY_algo_HitTri.__interfaces__ = [pixelimageXY_algo_IhitObj];
pixelimageXY_algo_HitTri.prototype = {
	__class__: pixelimageXY_algo_HitTri
};
var pixelimageXY_algo_HitTriArray = function(triArr) {
	this.triArr = triArr;
};
pixelimageXY_algo_HitTriArray.__name__ = "pixelimageXY.algo.HitTriArray";
pixelimageXY_algo_HitTriArray.__interfaces__ = [pixelimageXY_algo_IhitObj];
pixelimageXY_algo_HitTriArray.prototype = {
	__class__: pixelimageXY_algo_HitTriArray
};
var pixelimageXY_iter_IntIterStart = function(min_,max_) {
	this.start = min_;
	this.max = max_;
};
pixelimageXY_iter_IntIterStart.__name__ = "pixelimageXY.iter.IntIterStart";
pixelimageXY_iter_IntIterStart.prototype = {
	__class__: pixelimageXY_iter_IntIterStart
};
var triangleGML_ShapeInterface = function() { };
triangleGML_ShapeInterface.__name__ = "triangleGML.ShapeInterface";
triangleGML_ShapeInterface.__isInterface__ = true;
triangleGML_ShapeInterface.prototype = {
	__class__: triangleGML_ShapeInterface
};
var triangleGML_GroupShape = function(opacity,visibility) {
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	this.scaleY = 1.;
	this.scaleX = 1.;
	this.skewY = 0.;
	this.skewX = 0.;
	this.transformCentreY = 0.;
	this.transformCentreX = 0.;
	this.rotation = 0.;
	this.externalSoft = false;
	this.edgeSoft = 0;
	this.hitObj = null;
	this.offY = 0.;
	this.offX = 0.;
	this.visibility = visibility;
	this.opacity = opacity;
};
triangleGML_GroupShape.__name__ = "triangleGML.GroupShape";
triangleGML_GroupShape.__interfaces__ = [triangleGML_ShapeInterface];
triangleGML_GroupShape.prototype = {
	setParameter: function(name,value) {
		switch(name) {
		case "edgeSoft":
			this.edgeSoft = parseFloat(value);
			break;
		case "externalSoft":
			this.externalSoft = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "opacity":
			this.opacity = parseFloat(value);
			break;
		case "rotation":
			var degree = parseFloat(value);
			this.rotation = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "scale":
			this.scaleX = this.scaleY = parseFloat(value);
			break;
		case "scaleX":
			this.scaleX = parseFloat(value);
			break;
		case "scaleY":
			this.scaleY = parseFloat(value);
			break;
		case "skewX":
			this.skewX = parseFloat(value);
			break;
		case "skewY":
			this.skewY = parseFloat(value);
			break;
		case "theta":
			this.rotation = parseFloat(value);
			break;
		case "transformCentreX":
			this.transformCentreX = parseFloat(value);
			break;
		case "transformCentreY":
			this.transformCentreY = parseFloat(value);
			break;
		case "visibility":
			this.visibility = value.toLowerCase() == "true";
			break;
		default:
			haxe_Log.trace("property not found " + name,{ fileName : "triangleGML/GroupShape.hx", lineNumber : 58, className : "triangleGML.GroupShape", methodName : "setParameter"});
		}
	}
	,translate: function(x,y) {
		this.offX = x;
		this.offY = y;
	}
	,setImage: function(name,imageTool) {
		return imageTool;
	}
	,__class__: triangleGML_GroupShape
};
var triangleGML_BasicShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray) {
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_GroupShape.call(this,opacity,visibility);
	this.strokeColor = strokeColor;
	this.strokeWidth = strokeWidth;
	this.strokeDashGapArray = strokeDashGapArray;
};
triangleGML_BasicShape.__name__ = "triangleGML.BasicShape";
triangleGML_BasicShape.__super__ = triangleGML_GroupShape;
triangleGML_BasicShape.prototype = $extend(triangleGML_GroupShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "strokeColor":
			this.strokeColor = Std.parseInt(value);
			break;
		case "strokeDashGapArray":
			this.strokeDashGapArray = null;
			break;
		case "strokeWidth":
			this.strokeWidth = parseFloat(value);
			break;
		default:
			triangleGML_GroupShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: triangleGML_BasicShape
});
var triangleGML_FillForm = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill) {
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_BasicShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
	this.fill = fill;
};
triangleGML_FillForm.__name__ = "triangleGML.FillForm";
triangleGML_FillForm.__super__ = triangleGML_BasicShape;
triangleGML_FillForm.prototype = $extend(triangleGML_BasicShape.prototype,{
	setParameter: function(name,value) {
		if(name == "fill") {
			this.fill = Std.parseInt(value);
		} else {
			triangleGML_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: triangleGML_FillForm
});
var triangleGML_shape_form_ArcForm_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle,arcType) {
	if(arcType == null) {
		arcType = "pie";
	}
	if(sweepAngle == null) {
		sweepAngle = 0.;
	}
	if(startAngle == null) {
		startAngle = 0.;
	}
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_FillForm.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.startAngle = startAngle;
	this.sweepAngle = sweepAngle;
	this.arcType = arcType;
	this.rx = width / 2;
	this.ry = height / 2;
};
triangleGML_shape_form_ArcForm_$.__name__ = "triangleGML.shape.form.ArcForm_";
triangleGML_shape_form_ArcForm_$.__super__ = triangleGML_FillForm;
triangleGML_shape_form_ArcForm_$.prototype = $extend(triangleGML_FillForm.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "arcType":
			this.arcType = js_Boot.__cast(value , String);
			break;
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "startAngle":
			var degree = parseFloat(value);
			this.startAngle = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "sweepAngle":
			var degree = parseFloat(value);
			this.sweepAngle = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			triangleGML_FillForm.prototype.setParameter.call(this,name,value);
		}
		this.rx = this.width / 2;
		this.ry = this.height / 2;
	}
	,__class__: triangleGML_shape_form_ArcForm_$
});
var pixelimageXY_triangleGML_ArcForm = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle,arcType) {
	triangleGML_shape_form_ArcForm_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle,arcType);
};
pixelimageXY_triangleGML_ArcForm.__name__ = "pixelimageXY.triangleGML.ArcForm";
pixelimageXY_triangleGML_ArcForm.__super__ = triangleGML_shape_form_ArcForm_$;
pixelimageXY_triangleGML_ArcForm.prototype = $extend(triangleGML_shape_form_ArcForm_$.prototype,{
	render: function(pixelShape) {
		var w = Math.ceil(this.width);
		var h = Math.ceil(this.height);
		var this1 = new Uint32Array(w * h | 0);
		var this2 = new pixelimageXY_ImageStruct(w,h,this1);
		var this1 = this2;
		var temp = this1;
		temp.transparent = false;
		switch(this.arcType) {
		case "chord":
			this.chord(temp);
			break;
		case "ellipse":
			this.ellipse(temp);
			break;
		case "pie":
			this.pie(temp);
			break;
		}
		var x = this.left + this.offX | 0;
		var y = this.top + this.offY | 0;
		var _g = 0;
		var _g1 = temp.height;
		while(_g < _g1) {
			var dy = _g++;
			var _g2 = 0;
			var _g3 = temp.width;
			while(_g2 < _g3) {
				var dx = _g2++;
				var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
				var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(temp.useMask && temp.mask != null) {
					var this1 = temp.mask;
					var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
					var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					var maskPixel = this2;
					var this3 = col;
					var this4 = this3;
					if(maskPixel == 0) {
						var this5 = this4;
						col = this5;
					} else {
						var this6 = maskPixel >> 24 & 255;
						var m0 = this6 == 0 ? 0. : this6 / 255;
						var this7 = maskPixel >> 16 & 255;
						var m1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = maskPixel >> 8 & 255;
						var m2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = maskPixel & 255;
						var m3 = this9 == 0 ? 0. : this9 / 255;
						var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
						var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
						var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
						var ch3 = (1. - m3) * (this4 & 255) | 0;
						col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
					}
				}
				if(col != 0) {
					var x1 = x + dx;
					var y1 = y + dy;
					var this10 = col;
					var c2 = this10;
					if((c2 >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0;
						var this11 = pixelShape.image[location];
						var this12 = this11;
						var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
						var this14 = this13 >> 24 & 255;
						var a1 = this14 == 0 ? 0. : this14 / 255;
						var this15 = this13 >> 16 & 255;
						var r1 = this15 == 0 ? 0. : this15 / 255;
						var this16 = this13 >> 8 & 255;
						var g1 = this16 == 0 ? 0. : this16 / 255;
						var this17 = this13 & 255;
						var b1 = this17 == 0 ? 0. : this17 / 255;
						var this18 = col >> 24 & 255;
						var a2 = this18 == 0 ? 0. : this18 / 255;
						var this19 = col >> 16 & 255;
						var r2 = this19 == 0 ? 0. : this19 / 255;
						var this20 = col >> 8 & 255;
						var g2 = this20 == 0 ? 0. : this20 / 255;
						var this21 = col & 255;
						var b2 = this21 == 0 ? 0. : this21 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					}
				}
			}
		}
		temp = null;
		return pixelShape;
	}
	,chord: function(temp) {
		this.ellipse(temp);
		var endAngle = this.startAngle + this.sweepAngle;
		var bx = this.rx * Math.cos(this.startAngle) + this.rx;
		var by = this.ry * Math.sin(this.startAngle) + this.ry;
		var cx = this.rx * Math.cos(endAngle) + this.rx;
		var cy = this.ry * Math.sin(endAngle) + this.ry;
		if(this.sweepAngle < Math.PI) {
			var bxS = (this.rx - this.strokeWidth) * Math.cos(this.startAngle) + this.rx;
			var byS = (this.ry - this.strokeWidth) * Math.sin(this.startAngle) + this.ry;
			var cxS = (this.rx - this.strokeWidth) * Math.cos(endAngle + 0.01) + this.rx;
			var cyS = (this.ry - this.strokeWidth) * Math.sin(endAngle + 0.01) + this.ry;
			var d = this.strokeWidth;
			var x = this.rx - d / 2;
			var y = this.ry - d / 2;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + d | 0;
			var maxY = y + d | 0;
			while(true) {
				var x = p++;
				var this1 = 0;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 0;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var ax = this.rx;
			var ay = this.ry;
			var color = this.strokeColor;
			var bx1 = bx;
			var by1 = by;
			var cx1 = cx;
			var cy1 = cy;
			var hasHit = false;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit1 = hasHit;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx1 > cx1) {
				var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by1 > cy1) {
				var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo1) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx = _g2++;
						var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(temp.useMask && temp.mask != null) {
							var this1 = temp.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx - rectLeft;
							var y = dy - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && temp.transparent) {
							var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
							var this2 = temp.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == true) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo1) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var ax = this.rx;
			var ay = this.ry;
			var bx1 = bxS;
			var by1 = byS;
			var cx1 = cxS;
			var cy1 = cyS;
			var hasHit = false;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit1 = hasHit;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx1 > cx1) {
				var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by1 > cy1) {
				var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo1) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx = _g2++;
						var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(temp.useMask && temp.mask != null) {
							var this1 = temp.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx - rectLeft;
							var y = dy - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = 0;
						var c = this1;
						if((c >> 24 & 255) < 254 && temp.transparent) {
							var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
							var this2 = temp.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = 0;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = 0;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = 0;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = 0;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == true) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo1) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
		} else {
			var ax = this.rx;
			var ay = this.ry;
			var rx = this.rx;
			var ry = this.ry;
			var color = this.strokeColor;
			var currAngle = endAngle;
			var bx1 = rx * Math.cos(currAngle) + ax;
			var by1 = ry * Math.sin(currAngle) + ay;
			currAngle = endAngle + (2 * Math.PI - this.sweepAngle + 0.01);
			var cx1 = rx * Math.cos(currAngle) + ax;
			var cy1 = ry * Math.sin(currAngle) + ay;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			var bx2 = bx1;
			var by2 = by1;
			var cx2 = cx1;
			var cy2 = cy1;
			var hasHit1 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = ax * by2 - bx2 * ay + (bx2 * cy2 - cx2 * by2) + (cx2 * ay - ax * cy2) > 0;
			if(!adjustWinding) {
				var bx_ = bx2;
				var by_ = by2;
				bx2 = cx2;
				by2 = cy2;
				cx2 = bx_;
				cy2 = by_;
			}
			var hasHit = hasHit1;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var s0 = ay * cx2 - ax * cy2;
			var sx = cy2 - ay;
			var sy = ax - cx2;
			var t0 = ax * by2 - ay * bx2;
			var tx = ay - by2;
			var ty = bx2 - ax;
			var A = -by2 * cx2 + ay * (-bx2 + cx2) + ax * (by2 - cy2) + bx2 * cy2;
			var xIter3;
			if(ax > bx2) {
				if(ax > cx2) {
					var ii_min = bx2 > cx2 ? Math.floor(cx2) : Math.floor(bx2);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx2);
					var ii_max = Math.ceil(cx2);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx2 > cx2) {
				var ii_min = ax > cx2 ? Math.floor(cx2) : Math.ceil(ax);
				var ii_max = Math.ceil(bx2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by2) {
				if(ay > cy2) {
					var ii_min = by2 > cy2 ? Math.floor(cy2) : Math.floor(by2);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by2);
					var ii_max = Math.ceil(cy2);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by2 > cy2) {
				var ii_min = ay > cy2 ? Math.floor(cy2) : Math.ceil(ay);
				var ii_max = Math.ceil(by2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo1) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx = _g2++;
						var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(temp.useMask && temp.mask != null) {
							var this1 = temp.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx - rectLeft;
							var y = dy - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && temp.transparent) {
							var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
							var this2 = temp.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == true) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx2,by2,cx2,cy2,true);
				if(hasUndo1) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var ax = this.rx;
			var ay = this.ry;
			var rx = this.rx - this.strokeWidth;
			var ry = this.ry - this.strokeWidth;
			var color = this.fill;
			var currAngle = endAngle;
			var bx1 = rx * Math.cos(currAngle) + ax;
			var by1 = ry * Math.sin(currAngle) + ay;
			currAngle = endAngle + (2 * Math.PI - this.sweepAngle + 0.01);
			var cx1 = rx * Math.cos(currAngle) + ax;
			var cy1 = ry * Math.sin(currAngle) + ay;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			var bx2 = bx1;
			var by2 = by1;
			var cx2 = cx1;
			var cy2 = cy1;
			var hasHit1 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = ax * by2 - bx2 * ay + (bx2 * cy2 - cx2 * by2) + (cx2 * ay - ax * cy2) > 0;
			if(!adjustWinding) {
				var bx_ = bx2;
				var by_ = by2;
				bx2 = cx2;
				by2 = cy2;
				cx2 = bx_;
				cy2 = by_;
			}
			var hasHit = hasHit1;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var s0 = ay * cx2 - ax * cy2;
			var sx = cy2 - ay;
			var sy = ax - cx2;
			var t0 = ax * by2 - ay * bx2;
			var tx = ay - by2;
			var ty = bx2 - ax;
			var A = -by2 * cx2 + ay * (-bx2 + cx2) + ax * (by2 - cy2) + bx2 * cy2;
			var xIter3;
			if(ax > bx2) {
				if(ax > cx2) {
					var ii_min = bx2 > cx2 ? Math.floor(cx2) : Math.floor(bx2);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx2);
					var ii_max = Math.ceil(cx2);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx2 > cx2) {
				var ii_min = ax > cx2 ? Math.floor(cx2) : Math.ceil(ax);
				var ii_max = Math.ceil(bx2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by2) {
				if(ay > cy2) {
					var ii_min = by2 > cy2 ? Math.floor(cy2) : Math.floor(by2);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by2);
					var ii_max = Math.ceil(cy2);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by2 > cy2) {
				var ii_min = ay > cy2 ? Math.floor(cy2) : Math.ceil(ay);
				var ii_max = Math.ceil(by2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo1) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx = _g2++;
						var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(temp.useMask && temp.mask != null) {
							var this1 = temp.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx - rectLeft;
							var y = dy - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && temp.transparent) {
							var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
							var this2 = temp.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == true) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx2,by2,cx2,cy2,true);
				if(hasUndo1) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var color = this.strokeColor;
			var o = by - cy;
			var a = bx - cx;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var hasHit = true;
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx1 = h;
			var cy1 = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp1 = 0.;
			temp1 = cx + (ax * cos - ay * sin);
			ay = cy + (ay * cos + ax * sin);
			ax = temp1;
			temp1 = cx + (bx * cos - by * sin);
			by = cy + (by * cos + bx * sin);
			bx = temp1;
			temp1 = cx + (cx1 * cos - cy1 * sin);
			cy1 = cy + (cy1 * cos + cx1 * sin);
			cx1 = temp1;
			temp1 = cx + (dx * cos - dy * sin);
			dy = cy + (dy * cos + dx * sin);
			dx = temp1;
			if(debugCorners) {
				var x = ax - 6.;
				var y = ay - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -65536;
					var c = this1;
					if((c >> 24 & 255) < 254 && temp.transparent) {
						var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
						var this2 = temp.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = bx - 6.;
				var y = by - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -16711936;
					var c = this1;
					if((c >> 24 & 255) < 254 && temp.transparent) {
						var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
						var this2 = temp.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 0;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = cx1 - 6.;
				var y = cy1 - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -16776961;
					var c = this1;
					if((c >> 24 & 255) < 254 && temp.transparent) {
						var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
						var this2 = temp.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 0;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = dx - 6.;
				var y = dy - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -1048336;
					var c = this1;
					if((c >> 24 & 255) < 254 && temp.transparent) {
						var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
						var this2 = temp.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 240;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 240;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
			}
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx = dx;
			var cy = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy - cx * by1) + (cx * ay - ax * cy) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx;
				by1 = cy;
				cx = bx_;
				cy = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = ay * cx - ax * cy;
			var sx = cy - ay;
			var sy = ax - cx;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx + ay * (-bx1 + cx) + ax * (by1 - cy) + bx1 * cy;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx) {
					var ii_min = bx1 > cx ? Math.floor(cx) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx1 > cx) {
				var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy) {
					var ii_min = by1 > cy ? Math.floor(cy) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by1 > cy) {
				var ii_min = ay > cy ? Math.floor(cy) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = temp.image[temp.useVirtualPos ? (dy1 - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy1 * temp.width + dx1 | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(temp.useMask && temp.mask != null) {
							var this1 = temp.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && temp.transparent) {
							var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
							var this2 = temp.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx,cy,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var bx1 = cx1;
			var by1 = cy1;
			var cx = dx;
			var cy = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy - cx * by1) + (cx * by - bx * cy) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx;
				by1 = cy;
				cx = bx_;
				cy = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = by * cx - bx * cy;
			var sx = cy - by;
			var sy = bx - cx;
			var t0 = bx * by1 - by * bx1;
			var tx = by - by1;
			var ty = bx1 - bx;
			var A = -by1 * cx + by * (-bx1 + cx) + bx * (by1 - cy) + bx1 * cy;
			var xIter3;
			if(bx > bx1) {
				if(bx > cx) {
					var ii_min = bx1 > cx ? Math.floor(cx) : Math.floor(bx1);
					var ii_max = Math.ceil(bx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx1 > cx) {
				var ii_min = bx > cx ? Math.floor(cx) : Math.ceil(bx);
				var ii_max = Math.ceil(bx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(by > by1) {
				if(by > cy) {
					var ii_min = by1 > cy ? Math.floor(cy) : Math.floor(by1);
					var ii_max = Math.ceil(by);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by1 > cy) {
				var ii_min = by > cy ? Math.floor(cy) : Math.ceil(by);
				var ii_max = Math.ceil(by1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = temp.image[temp.useVirtualPos ? (dy1 - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy1 * temp.width + dx1 | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(temp.useMask && temp.mask != null) {
							var this1 = temp.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && temp.transparent) {
							var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
							var this2 = temp.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pixelimageXY_algo_HitTri(bx,by,bx1,by1,cx,cy,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			if(hasHit1 == true) {
				var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx1,cy1,dx,dy,true);
			}
		}
	}
	,ellipse: function(temp) {
		var ax = this.rx;
		var ay = this.ry;
		var rx = this.rx;
		var ry = this.ry;
		var startRadian = this.startAngle;
		var sweepRadian = this.sweepAngle;
		var color = this.strokeColor;
		var rSmall = rx > ry ? ry : rx;
		var targetE = 1.05;
		if(targetE == null) {
			targetE = 1.05;
		}
		var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
		var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
		var theta = 1.41213 * Math.PI / noSides;
		var currAngle = startRadian;
		var tot = Math.floor(sweepRadian / theta);
		theta += (sweepRadian / theta - tot) / noSides;
		tot = Math.floor(sweepRadian / theta);
		var bx = rx * Math.cos(currAngle) + ax;
		var by = ry * Math.sin(currAngle) + ay;
		var cx = 0.;
		var cy = 0.;
		var arrTri = [];
		var _g = 1;
		var _g1 = tot + 1;
		while(_g < _g1) {
			var i = _g++;
			currAngle = startRadian + i * theta;
			cx = rx * Math.cos(currAngle) + ax;
			cy = ry * Math.sin(currAngle) + ay;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = cx;
			var cy1 = cy;
			var hasHit1 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit1;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min1 = Math.floor(bx1);
					var ii_max1 = Math.ceil(cx1);
					var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
					xIter3 = this2;
				}
			} else if(bx1 > cx1) {
				var ii_min2 = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max2 = Math.ceil(bx1);
				var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
				xIter3 = this3;
			} else {
				var ii_min3 = Math.floor(ax);
				var ii_max3 = Math.ceil(cx1);
				var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
				xIter3 = this4;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min4 = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max4 = Math.ceil(ay);
					var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
					yIter3 = this5;
				} else {
					var ii_min5 = Math.floor(by1);
					var ii_max5 = Math.ceil(cy1);
					var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
					yIter3 = this6;
				}
			} else if(by1 > cy1) {
				var ii_min6 = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max6 = Math.ceil(by1);
				var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
				yIter3 = this7;
			} else {
				var ii_min7 = Math.floor(ay);
				var ii_max7 = Math.ceil(cy1);
				var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
				yIter3 = this8;
			}
			var undoImage = null;
			if(hasUndo1) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this9 = new Uint32Array(w * h | 0);
				var this10 = new pixelimageXY_ImageStruct(w,h,this9);
				undoImage = this10;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g2 = rectTop;
				var _g3 = yIter3.max;
				while(_g2 < _g3) {
					var dy = _g2++;
					var _g4 = rectLeft;
					var _g5 = rectRight;
					while(_g4 < _g5) {
						var dx = _g4++;
						var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(temp.useMask && temp.mask != null) {
							var this11 = temp.mask;
							var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
							var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this12;
							var this13 = col;
							var this14 = this13;
							if(maskPixel == 0) {
								var this15 = this14;
								col = this15;
							} else {
								var this16 = maskPixel >> 24 & 255;
								var m0 = this16 == 0 ? 0. : this16 / 255;
								var this17 = maskPixel >> 16 & 255;
								var m1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = maskPixel >> 8 & 255;
								var m2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = maskPixel & 255;
								var m3 = this19 == 0 ? 0. : this19 / 255;
								var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this14 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx - rectLeft;
							var y = dy - rectTop;
							var this20 = col;
							var c2 = this20;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this21 = undoImage.image[location];
								var this22 = this21;
								var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
								var this24 = this23 >> 24 & 255;
								var a1 = this24 == 0 ? 0. : this24 / 255;
								var this25 = this23 >> 16 & 255;
								var r1 = this25 == 0 ? 0. : this25 / 255;
								var this26 = this23 >> 8 & 255;
								var g1 = this26 == 0 ? 0. : this26 / 255;
								var this27 = this23 & 255;
								var b1 = this27 == 0 ? 0. : this27 / 255;
								var this28 = col >> 24 & 255;
								var a2 = this28 == 0 ? 0. : this28 / 255;
								var this29 = col >> 16 & 255;
								var r2 = this29 == 0 ? 0. : this29 / 255;
								var this30 = col >> 8 & 255;
								var g2 = this30 == 0 ? 0. : this30 / 255;
								var this31 = col & 255;
								var b2 = this31 == 0 ? 0. : this31 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x1 = _g_min++;
				sxx = sx * x1;
				txx = tx * x1;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y1 = _g_min1++;
					s = s0 + sxx + sy * y1;
					t = t0 + txx + ty * y1;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this32 = color;
						var c3 = this32;
						if((c3 >> 24 & 255) < 254 && temp.transparent) {
							var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
							var this33 = temp.image[location1];
							var this34 = this33;
							var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
							var this36 = this35 >> 24 & 255;
							var a11 = this36 == 0 ? 0. : this36 / 255;
							var this37 = this35 >> 16 & 255;
							var r11 = this37 == 0 ? 0. : this37 / 255;
							var this38 = this35 >> 8 & 255;
							var g11 = this38 == 0 ? 0. : this38 / 255;
							var this39 = this35 & 255;
							var b11 = this39 == 0 ? 0. : this39 / 255;
							var this40 = color >> 24 & 255;
							var a21 = this40 == 0 ? 0. : this40 / 255;
							var this41 = color >> 16 & 255;
							var r21 = this41 == 0 ? 0. : this41 / 255;
							var this42 = color >> 8 & 255;
							var g21 = this42 == 0 ? 0. : this42 / 255;
							var this43 = color & 255;
							var b21 = this43 == 0 ? 0. : this43 / 255;
							var a31 = a11 * (1 - a21);
							var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
							var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
							var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
							var a4 = 255 * (a31 + a21) | 0;
							var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
						} else {
							temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			var triHit;
			if(hasHit2 == true) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo1) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
				triHit = v;
			} else {
				triHit = null;
			}
			bx = cx;
			by = cy;
		}
		currAngle = startRadian + sweepRadian;
		cx = rx * Math.cos(currAngle) + ax;
		cy = ry * Math.sin(currAngle) + ay;
		var hasHit = false;
		if(hasHit == null) {
			hasHit = false;
		}
		var bx1 = bx;
		var by1 = by;
		var cx1 = cx;
		var cy1 = cy;
		var hasHit1 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var hasHit = hasHit1;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var xIter3;
		if(ax > bx1) {
			if(ax > cx1) {
				var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx1 > cx1) {
			var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
			var ii_max = Math.ceil(bx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(ay > by1) {
			if(ay > cy1) {
				var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
				var ii_max = Math.ceil(ay);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by1 > cy1) {
			var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
			var ii_max = Math.ceil(by1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(ay);
			var ii_max = Math.ceil(cy1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo1) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && temp.transparent) {
						var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
						var this2 = temp.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var triHit;
		if(hasHit == true) {
			var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
			if(hasUndo1) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			triHit = v;
		} else {
			triHit = null;
		}
		arrTri = null;
		var ax = this.rx;
		var ay = this.ry;
		var rx = this.rx - this.strokeWidth;
		var ry = this.ry - this.strokeWidth;
		var startRadian = this.startAngle;
		var sweepRadian = this.sweepAngle;
		var color = this.fill;
		var rSmall = rx > ry ? ry : rx;
		var targetE = 1.05;
		if(targetE == null) {
			targetE = 1.05;
		}
		var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
		var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
		var theta = 1.41213 * Math.PI / noSides;
		var currAngle = startRadian;
		var tot = Math.floor(sweepRadian / theta);
		theta += (sweepRadian / theta - tot) / noSides;
		tot = Math.floor(sweepRadian / theta);
		var bx = rx * Math.cos(currAngle) + ax;
		var by = ry * Math.sin(currAngle) + ay;
		var cx = 0.;
		var cy = 0.;
		var arrTri = [];
		var _g = 1;
		var _g1 = tot + 1;
		while(_g < _g1) {
			var i = _g++;
			currAngle = startRadian + i * theta;
			cx = rx * Math.cos(currAngle) + ax;
			cy = ry * Math.sin(currAngle) + ay;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = cx;
			var cy1 = cy;
			var hasHit1 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit1;
			var hasUndo1 = hasUndo;
			if(hasUndo1 == null) {
				hasUndo1 = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min1 = Math.floor(bx1);
					var ii_max1 = Math.ceil(cx1);
					var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
					xIter3 = this2;
				}
			} else if(bx1 > cx1) {
				var ii_min2 = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max2 = Math.ceil(bx1);
				var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
				xIter3 = this3;
			} else {
				var ii_min3 = Math.floor(ax);
				var ii_max3 = Math.ceil(cx1);
				var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
				xIter3 = this4;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min4 = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max4 = Math.ceil(ay);
					var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
					yIter3 = this5;
				} else {
					var ii_min5 = Math.floor(by1);
					var ii_max5 = Math.ceil(cy1);
					var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
					yIter3 = this6;
				}
			} else if(by1 > cy1) {
				var ii_min6 = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max6 = Math.ceil(by1);
				var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
				yIter3 = this7;
			} else {
				var ii_min7 = Math.floor(ay);
				var ii_max7 = Math.ceil(cy1);
				var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
				yIter3 = this8;
			}
			var undoImage = null;
			if(hasUndo1) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this9 = new Uint32Array(w * h | 0);
				var this10 = new pixelimageXY_ImageStruct(w,h,this9);
				undoImage = this10;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g2 = rectTop;
				var _g3 = yIter3.max;
				while(_g2 < _g3) {
					var dy = _g2++;
					var _g4 = rectLeft;
					var _g5 = rectRight;
					while(_g4 < _g5) {
						var dx = _g4++;
						var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(temp.useMask && temp.mask != null) {
							var this11 = temp.mask;
							var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
							var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this12;
							var this13 = col;
							var this14 = this13;
							if(maskPixel == 0) {
								var this15 = this14;
								col = this15;
							} else {
								var this16 = maskPixel >> 24 & 255;
								var m0 = this16 == 0 ? 0. : this16 / 255;
								var this17 = maskPixel >> 16 & 255;
								var m1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = maskPixel >> 8 & 255;
								var m2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = maskPixel & 255;
								var m3 = this19 == 0 ? 0. : this19 / 255;
								var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this14 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx - rectLeft;
							var y = dy - rectTop;
							var this20 = col;
							var c2 = this20;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this21 = undoImage.image[location];
								var this22 = this21;
								var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
								var this24 = this23 >> 24 & 255;
								var a1 = this24 == 0 ? 0. : this24 / 255;
								var this25 = this23 >> 16 & 255;
								var r1 = this25 == 0 ? 0. : this25 / 255;
								var this26 = this23 >> 8 & 255;
								var g1 = this26 == 0 ? 0. : this26 / 255;
								var this27 = this23 & 255;
								var b1 = this27 == 0 ? 0. : this27 / 255;
								var this28 = col >> 24 & 255;
								var a2 = this28 == 0 ? 0. : this28 / 255;
								var this29 = col >> 16 & 255;
								var r2 = this29 == 0 ? 0. : this29 / 255;
								var this30 = col >> 8 & 255;
								var g2 = this30 == 0 ? 0. : this30 / 255;
								var this31 = col & 255;
								var b2 = this31 == 0 ? 0. : this31 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x1 = _g_min++;
				sxx = sx * x1;
				txx = tx * x1;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y1 = _g_min1++;
					s = s0 + sxx + sy * y1;
					t = t0 + txx + ty * y1;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this32 = color;
						var c3 = this32;
						if((c3 >> 24 & 255) < 254 && temp.transparent) {
							var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
							var this33 = temp.image[location1];
							var this34 = this33;
							var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
							var this36 = this35 >> 24 & 255;
							var a11 = this36 == 0 ? 0. : this36 / 255;
							var this37 = this35 >> 16 & 255;
							var r11 = this37 == 0 ? 0. : this37 / 255;
							var this38 = this35 >> 8 & 255;
							var g11 = this38 == 0 ? 0. : this38 / 255;
							var this39 = this35 & 255;
							var b11 = this39 == 0 ? 0. : this39 / 255;
							var this40 = color >> 24 & 255;
							var a21 = this40 == 0 ? 0. : this40 / 255;
							var this41 = color >> 16 & 255;
							var r21 = this41 == 0 ? 0. : this41 / 255;
							var this42 = color >> 8 & 255;
							var g21 = this42 == 0 ? 0. : this42 / 255;
							var this43 = color & 255;
							var b21 = this43 == 0 ? 0. : this43 / 255;
							var a31 = a11 * (1 - a21);
							var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
							var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
							var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
							var a4 = 255 * (a31 + a21) | 0;
							var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
						} else {
							temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			var triHit;
			if(hasHit2 == true) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo1) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
				triHit = v;
			} else {
				triHit = null;
			}
			bx = cx;
			by = cy;
		}
		currAngle = startRadian + sweepRadian;
		cx = rx * Math.cos(currAngle) + ax;
		cy = ry * Math.sin(currAngle) + ay;
		var hasHit = false;
		if(hasHit == null) {
			hasHit = false;
		}
		var bx1 = bx;
		var by1 = by;
		var cx1 = cx;
		var cy1 = cy;
		var hasHit1 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var hasHit = hasHit1;
		var hasUndo1 = hasUndo;
		if(hasUndo1 == null) {
			hasUndo1 = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var xIter3;
		if(ax > bx1) {
			if(ax > cx1) {
				var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx1 > cx1) {
			var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
			var ii_max = Math.ceil(bx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(ay > by1) {
			if(ay > cy1) {
				var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
				var ii_max = Math.ceil(ay);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by1 > cy1) {
			var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
			var ii_max = Math.ceil(by1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(ay);
			var ii_max = Math.ceil(cy1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo1) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && temp.transparent) {
						var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
						var this2 = temp.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var triHit;
		if(hasHit == true) {
			var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
			if(hasUndo1) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			triHit = v;
		} else {
			triHit = null;
		}
		arrTri = null;
	}
	,pie: function(temp) {
		this.ellipse(temp);
		var bx = this.rx * Math.cos(this.startAngle) + this.rx;
		var by = this.ry * Math.sin(this.startAngle) + this.ry;
		var currAngle = this.startAngle + this.sweepAngle / 2;
		var ax = this.strokeWidth * Math.cos(currAngle) + this.rx;
		var ay = this.strokeWidth * Math.sin(currAngle) + this.ry;
		currAngle = this.startAngle + this.sweepAngle;
		var cx = this.rx * Math.cos(currAngle) + this.rx;
		var cy = this.ry * Math.sin(currAngle) + this.ry;
		var px = this.rx;
		var py = this.ry;
		var color = this.strokeColor;
		var o = by - py;
		var a = bx - px;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var hasHit = true;
		var debugCorners = false;
		if(debugCorners == null) {
			debugCorners = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = this.strokeWidth / 2;
		var dx = 0.1;
		var dy = radius;
		var cx1 = h;
		var cy1 = radius;
		var bx = h;
		var by = -radius;
		var ax = 0.1;
		var ay = -radius;
		var temp1 = 0.;
		temp1 = px + (ax * cos - ay * sin);
		ay = py + (ay * cos + ax * sin);
		ax = temp1;
		temp1 = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp1;
		temp1 = px + (cx1 * cos - cy1 * sin);
		cy1 = py + (cy1 * cos + cx1 * sin);
		cx1 = temp1;
		temp1 = px + (dx * cos - dy * sin);
		dy = py + (dy * cos + dx * sin);
		dx = temp1;
		if(debugCorners) {
			var x = ax - 6.;
			var y = ay - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -65536;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = bx - 6.;
			var y = by - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16711936;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = cx1 - 6.;
			var y = cy1 - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16776961;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = dx - 6.;
			var y = dy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -1048336;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 240;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 240;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
		}
		var hasHit1 = hasHit;
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var bx1 = bx;
		var by1 = by;
		var cx2 = dx;
		var cy2 = dy;
		var hasHit = hasHit1;
		if(hasHit == null) {
			hasHit = false;
		}
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy2 - cx2 * by1) + (cx2 * ay - ax * cy2) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx2;
			by1 = cy2;
			cx2 = bx_;
			cy2 = by_;
		}
		var hasHit2 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit2 == null) {
			hasHit2 = false;
		}
		var s0 = ay * cx2 - ax * cy2;
		var sx = cy2 - ay;
		var sy = ax - cx2;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx2 + ay * (-bx1 + cx2) + ax * (by1 - cy2) + bx1 * cy2;
		var xIter3;
		if(ax > bx1) {
			if(ax > cx2) {
				var ii_min = bx1 > cx2 ? Math.floor(cx2) : Math.floor(bx1);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx1 > cx2) {
			var ii_min = ax > cx2 ? Math.floor(cx2) : Math.ceil(ax);
			var ii_max = Math.ceil(bx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx2);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(ay > by1) {
			if(ay > cy2) {
				var ii_min = by1 > cy2 ? Math.floor(cy2) : Math.floor(by1);
				var ii_max = Math.ceil(ay);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by1 > cy2) {
			var ii_min = ay > cy2 ? Math.floor(cy2) : Math.ceil(ay);
			var ii_max = Math.ceil(by1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(ay);
			var ii_max = Math.ceil(cy2);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = temp.image[temp.useVirtualPos ? (dy1 - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy1 * temp.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && temp.transparent) {
						var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
						var this2 = temp.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		if(hasHit2 == true) {
			var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx2,cy2,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
		}
		var bx1 = cx1;
		var by1 = cy1;
		var cx2 = dx;
		var cy2 = dy;
		var hasHit = hasHit1;
		if(hasHit == null) {
			hasHit = false;
		}
		var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy2 - cx2 * by1) + (cx2 * by - bx * cy2) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx2;
			by1 = cy2;
			cx2 = bx_;
			cy2 = by_;
		}
		var hasHit2 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit2 == null) {
			hasHit2 = false;
		}
		var s0 = by * cx2 - bx * cy2;
		var sx = cy2 - by;
		var sy = bx - cx2;
		var t0 = bx * by1 - by * bx1;
		var tx = by - by1;
		var ty = bx1 - bx;
		var A = -by1 * cx2 + by * (-bx1 + cx2) + bx * (by1 - cy2) + bx1 * cy2;
		var xIter3;
		if(bx > bx1) {
			if(bx > cx2) {
				var ii_min = bx1 > cx2 ? Math.floor(cx2) : Math.floor(bx1);
				var ii_max = Math.ceil(bx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx1 > cx2) {
			var ii_min = bx > cx2 ? Math.floor(cx2) : Math.ceil(bx);
			var ii_max = Math.ceil(bx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(bx);
			var ii_max = Math.ceil(cx2);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(by > by1) {
			if(by > cy2) {
				var ii_min = by1 > cy2 ? Math.floor(cy2) : Math.floor(by1);
				var ii_max = Math.ceil(by);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy2);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by1 > cy2) {
			var ii_min = by > cy2 ? Math.floor(cy2) : Math.ceil(by);
			var ii_max = Math.ceil(by1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(by);
			var ii_max = Math.ceil(cy2);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = temp.image[temp.useVirtualPos ? (dy1 - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy1 * temp.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && temp.transparent) {
						var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
						var this2 = temp.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		if(hasHit2 == true) {
			var v = new pixelimageXY_algo_HitTri(bx,by,bx1,by1,cx2,cy2,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
		}
		if(hasHit1 == true) {
			var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx1,cy1,dx,dy,true);
		}
		var px = this.rx;
		var py = this.ry;
		var color = this.strokeColor;
		var o = cy - py;
		var a = cx - px;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var hasHit = true;
		var debugCorners = false;
		if(debugCorners == null) {
			debugCorners = false;
		}
		if(hasHit == null) {
			hasHit = false;
		}
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = this.strokeWidth / 2;
		var dx = 0.1;
		var dy = radius;
		var cx = h;
		var cy = radius;
		var bx = h;
		var by = -radius;
		var ax = 0.1;
		var ay = -radius;
		var temp1 = 0.;
		temp1 = px + (ax * cos - ay * sin);
		ay = py + (ay * cos + ax * sin);
		ax = temp1;
		temp1 = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp1;
		temp1 = px + (cx * cos - cy * sin);
		cy = py + (cy * cos + cx * sin);
		cx = temp1;
		temp1 = px + (dx * cos - dy * sin);
		dy = py + (dy * cos + dx * sin);
		dx = temp1;
		if(debugCorners) {
			var x = ax - 6.;
			var y = ay - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -65536;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = bx - 6.;
			var y = by - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16711936;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = cx - 6.;
			var y = cy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16776961;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = dx - 6.;
			var y = dy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -1048336;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 240;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 240;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
		}
		var hasHit1 = hasHit;
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var bx1 = bx;
		var by1 = by;
		var cx1 = dx;
		var cy1 = dy;
		var hasHit = hasHit1;
		if(hasHit == null) {
			hasHit = false;
		}
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var hasHit2 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit2 == null) {
			hasHit2 = false;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var xIter3;
		if(ax > bx1) {
			if(ax > cx1) {
				var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx1 > cx1) {
			var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
			var ii_max = Math.ceil(bx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(ax);
			var ii_max = Math.ceil(cx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(ay > by1) {
			if(ay > cy1) {
				var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
				var ii_max = Math.ceil(ay);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by1 > cy1) {
			var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
			var ii_max = Math.ceil(by1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(ay);
			var ii_max = Math.ceil(cy1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = temp.image[temp.useVirtualPos ? (dy1 - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy1 * temp.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && temp.transparent) {
						var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
						var this2 = temp.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		if(hasHit2 == true) {
			var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
		}
		var bx1 = cx;
		var by1 = cy;
		var cx1 = dx;
		var cy1 = dy;
		var hasHit = hasHit1;
		if(hasHit == null) {
			hasHit = false;
		}
		var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var hasHit2 = hasHit;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit2 == null) {
			hasHit2 = false;
		}
		var s0 = by * cx1 - bx * cy1;
		var sx = cy1 - by;
		var sy = bx - cx1;
		var t0 = bx * by1 - by * bx1;
		var tx = by - by1;
		var ty = bx1 - bx;
		var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
		var xIter3;
		if(bx > bx1) {
			if(bx > cx1) {
				var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
				var ii_max = Math.ceil(bx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx1 > cx1) {
			var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
			var ii_max = Math.ceil(bx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(bx);
			var ii_max = Math.ceil(cx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(by > by1) {
			if(by > cy1) {
				var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
				var ii_max = Math.ceil(by);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by1 > cy1) {
			var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
			var ii_max = Math.ceil(by1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(by);
			var ii_max = Math.ceil(cy1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = temp.image[temp.useVirtualPos ? (dy1 - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy1 * temp.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && temp.transparent) {
						var location = temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0;
						var this2 = temp.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		if(hasHit2 == true) {
			var v = new pixelimageXY_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
		}
		if(hasHit1 == true) {
			var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
		}
	}
	,__class__: pixelimageXY_triangleGML_ArcForm
});
var triangleGML_shape_contour_ArrowShape_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,both,flare,reverseFlare,x1,y1,x2,y2,arrowWidth,arrowHeight) {
	if(arrowHeight == null) {
		arrowHeight = 0.;
	}
	if(arrowWidth == null) {
		arrowWidth = 0.;
	}
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(reverseFlare == null) {
		reverseFlare = false;
	}
	if(flare == null) {
		flare = false;
	}
	if(both == null) {
		both = false;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = -1048576;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_BasicShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
	this.both = both;
	this.flare = flare;
	this.reverseFlare = reverseFlare;
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.arrowHeight = arrowHeight;
	this.arrowWidth = arrowWidth;
};
triangleGML_shape_contour_ArrowShape_$.__name__ = "triangleGML.shape.contour.ArrowShape_";
triangleGML_shape_contour_ArrowShape_$.__super__ = triangleGML_BasicShape;
triangleGML_shape_contour_ArrowShape_$.prototype = $extend(triangleGML_BasicShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "arrowHeight":
			this.arrowHeight = parseFloat(value);
			break;
		case "arrowWidth":
			this.arrowWidth = parseFloat(value);
			break;
		case "both":
			this.both = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "flare":
			this.flare = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "reverseFlare":
			this.reverseFlare = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		default:
			triangleGML_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: triangleGML_shape_contour_ArrowShape_$
});
var pixelimageXY_triangleGML_ArrowShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,both,flare,reverseFlare,x1,y1,x2,y2,arrowWidth,arrowHeight) {
	triangleGML_shape_contour_ArrowShape_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,both,flare,reverseFlare,x1,y1,x2,y2,arrowWidth,arrowHeight);
};
pixelimageXY_triangleGML_ArrowShape.__name__ = "pixelimageXY.triangleGML.ArrowShape";
pixelimageXY_triangleGML_ArrowShape.__super__ = triangleGML_shape_contour_ArrowShape_$;
pixelimageXY_triangleGML_ArrowShape.prototype = $extend(triangleGML_shape_contour_ArrowShape_$.prototype,{
	render: function(pixelShape) {
		var px = this.x1 + this.offX;
		var qx = this.x2 + this.offX;
		var py = this.y1 + this.offY;
		var qy = this.y2 + this.offY;
		var arrowFixed = this.arrowHeight > 0. || this.arrowWidth > 0.;
		var hasSoftEdge = this.edgeSoft != 0;
		var doubleSided = this.both;
		haxe_Log.trace("render arrow",{ fileName : "pixelimageXY/triangleGML/ArrowShape.hx", lineNumber : 18, className : "pixelimageXY.triangleGML.ArrowShape", methodName : "render"});
		haxe_Log.trace("arrowHeight",{ fileName : "pixelimageXY/triangleGML/ArrowShape.hx", lineNumber : 19, className : "pixelimageXY.triangleGML.ArrowShape", methodName : "render"});
		haxe_Log.trace("arrowWidth",{ fileName : "pixelimageXY/triangleGML/ArrowShape.hx", lineNumber : 20, className : "pixelimageXY.triangleGML.ArrowShape", methodName : "render"});
		haxe_Log.trace("fixed arrow " + (arrowFixed == null ? "null" : "" + arrowFixed),{ fileName : "pixelimageXY/triangleGML/ArrowShape.hx", lineNumber : 22, className : "pixelimageXY.triangleGML.ArrowShape", methodName : "render"});
		haxe_Log.trace("arrow soft edge " + (hasSoftEdge == null ? "null" : "" + hasSoftEdge),{ fileName : "pixelimageXY/triangleGML/ArrowShape.hx", lineNumber : 23, className : "pixelimageXY.triangleGML.ArrowShape", methodName : "render"});
		haxe_Log.trace("arrow double sided " + Std.string(this.both),{ fileName : "pixelimageXY/triangleGML/ArrowShape.hx", lineNumber : 24, className : "pixelimageXY.triangleGML.ArrowShape", methodName : "render"});
		var qx = this.arrowWidth;
		var qy = this.arrowHeight;
		var thick = this.strokeWidth;
		var color = this.strokeColor;
		var flare = false;
		var reverseFlare = false;
		var hasHit = true;
		if(hasHit == null) {
			hasHit = false;
		}
		if(reverseFlare == null) {
			reverseFlare = false;
		}
		if(flare == null) {
			flare = false;
		}
		var goldenRatio = 1.61803398875;
		var o = qy - py;
		var a = qx - px;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var thicker = 2 * thick * goldenRatio;
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = thick / 2;
		var radius2 = thicker / 2;
		var h2 = h / goldenRatio;
		var hitQuad;
		if(flare) {
			if(reverseFlare) {
				var hasHit1 = true;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var sin1 = Math.sin(theta);
				var cos1 = Math.cos(theta);
				var radius1 = thick / 2;
				var radius21 = (thicker - (thicker - thick) / goldenRatio) / 2;
				var dx = 0.1;
				var dy = radius1;
				var cx = h2;
				var cy = radius21;
				var bx = h2;
				var by = -radius21;
				var ax = 0.1;
				var ay = -radius1;
				var temp = 0.;
				temp = px + (ax * cos1 - ay * sin1);
				ay = py + (ay * cos1 + ax * sin1);
				ax = temp;
				temp = px + (bx * cos1 - by * sin1);
				by = py + (by * cos1 + bx * sin1);
				bx = temp;
				temp = px + (cx * cos1 - cy * sin1);
				cy = py + (cy * cos1 + cx * sin1);
				cx = temp;
				temp = px + (dx * cos1 - dy * sin1);
				dy = py + (dy * cos1 + dx * sin1);
				dx = temp;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var bx1 = bx;
				var by1 = by;
				var cx1 = dx;
				var cy1 = dy;
				var hasHit1 = hasHit2;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx1;
					var by_ = by1;
					bx1 = cx1;
					by1 = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit3 = hasHit1;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit3 == null) {
					hasHit3 = false;
				}
				var s0 = ay * cx1 - ax * cy1;
				var sx = cy1 - ay;
				var sy = ax - cx1;
				var t0 = ax * by1 - ay * bx1;
				var tx = ay - by1;
				var ty = bx1 - ax;
				var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
				var xIter3;
				if(ax > bx1) {
					if(ax > cx1) {
						var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
						var ii_max = Math.ceil(ax);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(cx1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(bx1 > cx1) {
					var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
					var ii_max = Math.ceil(bx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(ax);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(ay > by1) {
					if(ay > cy1) {
						var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
						var ii_max = Math.ceil(ay);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(cy1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(by1 > cy1) {
					var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
					var ii_max = Math.ceil(by1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(ay);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				if(hasUndo) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this1 = new Uint32Array(w * h | 0);
					var this2 = new pixelimageXY_ImageStruct(w,h,this1);
					undoImage = this2;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g = rectTop;
					var _g1 = yIter3.max;
					while(_g < _g1) {
						var dy1 = _g++;
						var _g2 = rectLeft;
						var _g3 = rectRight;
						while(_g2 < _g3) {
							var dx1 = _g2++;
							var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(pixelShape.useMask && pixelShape.mask != null) {
								var this1 = pixelShape.mask;
								var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
								var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this2;
								var this3 = col;
								var this4 = this3;
								if(maskPixel == 0) {
									var this5 = this4;
									col = this5;
								} else {
									var this6 = maskPixel >> 24 & 255;
									var m0 = this6 == 0 ? 0. : this6 / 255;
									var this7 = maskPixel >> 16 & 255;
									var m1 = this7 == 0 ? 0. : this7 / 255;
									var this8 = maskPixel >> 8 & 255;
									var m2 = this8 == 0 ? 0. : this8 / 255;
									var this9 = maskPixel & 255;
									var m3 = this9 == 0 ? 0. : this9 / 255;
									var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this4 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy1 - rectTop;
								var this10 = col;
								var c2 = this10;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this11 = undoImage.image[location];
									var this12 = this11;
									var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
									var this14 = this13 >> 24 & 255;
									var a1 = this14 == 0 ? 0. : this14 / 255;
									var this15 = this13 >> 16 & 255;
									var r1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = this13 >> 8 & 255;
									var g1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = this13 & 255;
									var b1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = col >> 24 & 255;
									var a2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = col >> 16 & 255;
									var r2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = col >> 8 & 255;
									var g2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = col & 255;
									var b2 = this21 == 0 ? 0. : this21 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x = _g_min++;
					sxx = sx * x;
					txx = tx * x;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y = _g_min1++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this1 = color;
							var c = this1;
							if((c >> 24 & 255) < 254 && pixelShape.transparent) {
								var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
								var this2 = pixelShape.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = color >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit3 == true) {
					var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
					if(hasUndo) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				var bx1 = cx;
				var by1 = cy;
				var cx1 = dx;
				var cy1 = dy;
				var hasHit1 = hasHit2;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx1;
					var by_ = by1;
					bx1 = cx1;
					by1 = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit3 = hasHit1;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit3 == null) {
					hasHit3 = false;
				}
				var s0 = by * cx1 - bx * cy1;
				var sx = cy1 - by;
				var sy = bx - cx1;
				var t0 = bx * by1 - by * bx1;
				var tx = by - by1;
				var ty = bx1 - bx;
				var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
				var xIter3;
				if(bx > bx1) {
					if(bx > cx1) {
						var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
						var ii_max = Math.ceil(bx);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(cx1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(bx1 > cx1) {
					var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
					var ii_max = Math.ceil(bx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(by > by1) {
					if(by > cy1) {
						var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
						var ii_max = Math.ceil(by);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(cy1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(by1 > cy1) {
					var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
					var ii_max = Math.ceil(by1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				if(hasUndo) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this1 = new Uint32Array(w * h | 0);
					var this2 = new pixelimageXY_ImageStruct(w,h,this1);
					undoImage = this2;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g = rectTop;
					var _g1 = yIter3.max;
					while(_g < _g1) {
						var dy1 = _g++;
						var _g2 = rectLeft;
						var _g3 = rectRight;
						while(_g2 < _g3) {
							var dx1 = _g2++;
							var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(pixelShape.useMask && pixelShape.mask != null) {
								var this1 = pixelShape.mask;
								var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
								var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this2;
								var this3 = col;
								var this4 = this3;
								if(maskPixel == 0) {
									var this5 = this4;
									col = this5;
								} else {
									var this6 = maskPixel >> 24 & 255;
									var m0 = this6 == 0 ? 0. : this6 / 255;
									var this7 = maskPixel >> 16 & 255;
									var m1 = this7 == 0 ? 0. : this7 / 255;
									var this8 = maskPixel >> 8 & 255;
									var m2 = this8 == 0 ? 0. : this8 / 255;
									var this9 = maskPixel & 255;
									var m3 = this9 == 0 ? 0. : this9 / 255;
									var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this4 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy1 - rectTop;
								var this10 = col;
								var c2 = this10;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this11 = undoImage.image[location];
									var this12 = this11;
									var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
									var this14 = this13 >> 24 & 255;
									var a1 = this14 == 0 ? 0. : this14 / 255;
									var this15 = this13 >> 16 & 255;
									var r1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = this13 >> 8 & 255;
									var g1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = this13 & 255;
									var b1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = col >> 24 & 255;
									var a2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = col >> 16 & 255;
									var r2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = col >> 8 & 255;
									var g2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = col & 255;
									var b2 = this21 == 0 ? 0. : this21 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x = _g_min++;
					sxx = sx * x;
					txx = tx * x;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y = _g_min1++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this1 = color;
							var c = this1;
							if((c >> 24 & 255) < 254 && pixelShape.transparent) {
								var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
								var this2 = pixelShape.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = color >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit3 == true) {
					var v = new pixelimageXY_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
					if(hasUndo) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				if(hasHit2 == true) {
					var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
					hitQuad = v;
				} else {
					hitQuad = null;
				}
			} else {
				var hasHit1 = true;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var sin1 = Math.sin(theta);
				var cos1 = Math.cos(theta);
				var radius1 = (thicker - (thicker - thick) / goldenRatio) / 2;
				var radius21 = thick / 2;
				var dx = 0.1;
				var dy = radius1;
				var cx = h2;
				var cy = radius21;
				var bx = h2;
				var by = -radius21;
				var ax = 0.1;
				var ay = -radius1;
				var temp = 0.;
				temp = px + (ax * cos1 - ay * sin1);
				ay = py + (ay * cos1 + ax * sin1);
				ax = temp;
				temp = px + (bx * cos1 - by * sin1);
				by = py + (by * cos1 + bx * sin1);
				bx = temp;
				temp = px + (cx * cos1 - cy * sin1);
				cy = py + (cy * cos1 + cx * sin1);
				cx = temp;
				temp = px + (dx * cos1 - dy * sin1);
				dy = py + (dy * cos1 + dx * sin1);
				dx = temp;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var bx1 = bx;
				var by1 = by;
				var cx1 = dx;
				var cy1 = dy;
				var hasHit1 = hasHit2;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx1;
					var by_ = by1;
					bx1 = cx1;
					by1 = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit3 = hasHit1;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit3 == null) {
					hasHit3 = false;
				}
				var s0 = ay * cx1 - ax * cy1;
				var sx = cy1 - ay;
				var sy = ax - cx1;
				var t0 = ax * by1 - ay * bx1;
				var tx = ay - by1;
				var ty = bx1 - ax;
				var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
				var xIter3;
				if(ax > bx1) {
					if(ax > cx1) {
						var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
						var ii_max = Math.ceil(ax);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(cx1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(bx1 > cx1) {
					var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
					var ii_max = Math.ceil(bx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(ax);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(ay > by1) {
					if(ay > cy1) {
						var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
						var ii_max = Math.ceil(ay);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(cy1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(by1 > cy1) {
					var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
					var ii_max = Math.ceil(by1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(ay);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				if(hasUndo) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this1 = new Uint32Array(w * h | 0);
					var this2 = new pixelimageXY_ImageStruct(w,h,this1);
					undoImage = this2;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g = rectTop;
					var _g1 = yIter3.max;
					while(_g < _g1) {
						var dy1 = _g++;
						var _g2 = rectLeft;
						var _g3 = rectRight;
						while(_g2 < _g3) {
							var dx1 = _g2++;
							var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(pixelShape.useMask && pixelShape.mask != null) {
								var this1 = pixelShape.mask;
								var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
								var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this2;
								var this3 = col;
								var this4 = this3;
								if(maskPixel == 0) {
									var this5 = this4;
									col = this5;
								} else {
									var this6 = maskPixel >> 24 & 255;
									var m0 = this6 == 0 ? 0. : this6 / 255;
									var this7 = maskPixel >> 16 & 255;
									var m1 = this7 == 0 ? 0. : this7 / 255;
									var this8 = maskPixel >> 8 & 255;
									var m2 = this8 == 0 ? 0. : this8 / 255;
									var this9 = maskPixel & 255;
									var m3 = this9 == 0 ? 0. : this9 / 255;
									var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this4 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy1 - rectTop;
								var this10 = col;
								var c2 = this10;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this11 = undoImage.image[location];
									var this12 = this11;
									var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
									var this14 = this13 >> 24 & 255;
									var a1 = this14 == 0 ? 0. : this14 / 255;
									var this15 = this13 >> 16 & 255;
									var r1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = this13 >> 8 & 255;
									var g1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = this13 & 255;
									var b1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = col >> 24 & 255;
									var a2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = col >> 16 & 255;
									var r2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = col >> 8 & 255;
									var g2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = col & 255;
									var b2 = this21 == 0 ? 0. : this21 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x = _g_min++;
					sxx = sx * x;
					txx = tx * x;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y = _g_min1++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this1 = color;
							var c = this1;
							if((c >> 24 & 255) < 254 && pixelShape.transparent) {
								var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
								var this2 = pixelShape.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = color >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit3 == true) {
					var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
					if(hasUndo) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				var bx1 = cx;
				var by1 = cy;
				var cx1 = dx;
				var cy1 = dy;
				var hasHit1 = hasHit2;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx1;
					var by_ = by1;
					bx1 = cx1;
					by1 = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit3 = hasHit1;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit3 == null) {
					hasHit3 = false;
				}
				var s0 = by * cx1 - bx * cy1;
				var sx = cy1 - by;
				var sy = bx - cx1;
				var t0 = bx * by1 - by * bx1;
				var tx = by - by1;
				var ty = bx1 - bx;
				var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
				var xIter3;
				if(bx > bx1) {
					if(bx > cx1) {
						var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
						var ii_max = Math.ceil(bx);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(cx1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(bx1 > cx1) {
					var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
					var ii_max = Math.ceil(bx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(by > by1) {
					if(by > cy1) {
						var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
						var ii_max = Math.ceil(by);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(cy1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(by1 > cy1) {
					var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
					var ii_max = Math.ceil(by1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				if(hasUndo) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this1 = new Uint32Array(w * h | 0);
					var this2 = new pixelimageXY_ImageStruct(w,h,this1);
					undoImage = this2;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g = rectTop;
					var _g1 = yIter3.max;
					while(_g < _g1) {
						var dy1 = _g++;
						var _g2 = rectLeft;
						var _g3 = rectRight;
						while(_g2 < _g3) {
							var dx1 = _g2++;
							var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(pixelShape.useMask && pixelShape.mask != null) {
								var this1 = pixelShape.mask;
								var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
								var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this2;
								var this3 = col;
								var this4 = this3;
								if(maskPixel == 0) {
									var this5 = this4;
									col = this5;
								} else {
									var this6 = maskPixel >> 24 & 255;
									var m0 = this6 == 0 ? 0. : this6 / 255;
									var this7 = maskPixel >> 16 & 255;
									var m1 = this7 == 0 ? 0. : this7 / 255;
									var this8 = maskPixel >> 8 & 255;
									var m2 = this8 == 0 ? 0. : this8 / 255;
									var this9 = maskPixel & 255;
									var m3 = this9 == 0 ? 0. : this9 / 255;
									var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this4 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy1 - rectTop;
								var this10 = col;
								var c2 = this10;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this11 = undoImage.image[location];
									var this12 = this11;
									var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
									var this14 = this13 >> 24 & 255;
									var a1 = this14 == 0 ? 0. : this14 / 255;
									var this15 = this13 >> 16 & 255;
									var r1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = this13 >> 8 & 255;
									var g1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = this13 & 255;
									var b1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = col >> 24 & 255;
									var a2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = col >> 16 & 255;
									var r2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = col >> 8 & 255;
									var g2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = col & 255;
									var b2 = this21 == 0 ? 0. : this21 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x = _g_min++;
					sxx = sx * x;
					txx = tx * x;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y = _g_min1++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this1 = color;
							var c = this1;
							if((c >> 24 & 255) < 254 && pixelShape.transparent) {
								var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
								var this2 = pixelShape.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = color >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit3 == true) {
					var v = new pixelimageXY_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
					if(hasUndo) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				if(hasHit2 == true) {
					var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
					hitQuad = v;
				} else {
					hitQuad = null;
				}
			}
		} else {
			var hasHit1 = true;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var sin1 = Math.sin(theta);
			var cos1 = Math.cos(theta);
			var radius = thick / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h2;
			var cy = radius;
			var bx = h2;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = px + (ax * cos1 - ay * sin1);
			ay = py + (ay * cos1 + ax * sin1);
			ax = temp;
			temp = px + (bx * cos1 - by * sin1);
			by = py + (by * cos1 + bx * sin1);
			bx = temp;
			temp = px + (cx * cos1 - cy * sin1);
			cy = py + (cy * cos1 + cx * sin1);
			cx = temp;
			temp = px + (dx * cos1 - dy * sin1);
			dy = py + (dy * cos1 + dx * sin1);
			dx = temp;
			var hasHit2 = hasHit1;
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit1 = hasHit2;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit3 = hasHit1;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit3 == null) {
				hasHit3 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx1 > cx1) {
				var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by1 > cy1) {
				var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(pixelShape.useMask && pixelShape.mask != null) {
							var this1 = pixelShape.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && pixelShape.transparent) {
							var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
							var this2 = pixelShape.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit3 == true) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var bx1 = cx;
			var by1 = cy;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit1 = hasHit2;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit3 = hasHit1;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit3 == null) {
				hasHit3 = false;
			}
			var s0 = by * cx1 - bx * cy1;
			var sx = cy1 - by;
			var sy = bx - cx1;
			var t0 = bx * by1 - by * bx1;
			var tx = by - by1;
			var ty = bx1 - bx;
			var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(bx > bx1) {
				if(bx > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(bx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx1 > cx1) {
				var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
				var ii_max = Math.ceil(bx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(by > by1) {
				if(by > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(by);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by1 > cy1) {
				var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
				var ii_max = Math.ceil(by1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(pixelShape.useMask && pixelShape.mask != null) {
							var this1 = pixelShape.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && pixelShape.transparent) {
							var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
							var this2 = pixelShape.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit3 == true) {
				var v = new pixelimageXY_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			if(hasHit2 == true) {
				var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
				hitQuad = v;
			} else {
				hitQuad = null;
			}
		}
		var cx = h2;
		var cy = radius2;
		var bx = h2;
		var by = -radius2;
		var temp = 0.;
		temp = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp;
		temp = px + (cx * cos - cy * sin);
		cy = py + (cy * cos + cx * sin);
		cx = temp;
		var bx1 = bx;
		var by1 = by;
		var cx1 = cx;
		var cy1 = cy;
		var hasHit1 = hasHit;
		if(hasHit1 == null) {
			hasHit1 = false;
		}
		var adjustWinding = qx * by1 - bx1 * qy + (bx1 * cy1 - cx1 * by1) + (cx1 * qy - qx * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var hasHit2 = hasHit1;
		var hasUndo = false;
		if(hasUndo == null) {
			hasUndo = false;
		}
		if(hasHit2 == null) {
			hasHit2 = false;
		}
		var s0 = qy * cx1 - qx * cy1;
		var sx = cy1 - qy;
		var sy = qx - cx1;
		var t0 = qx * by1 - qy * bx1;
		var tx = qy - by1;
		var ty = bx1 - qx;
		var A = -by1 * cx1 + qy * (-bx1 + cx1) + qx * (by1 - cy1) + bx1 * cy1;
		var xIter3;
		if(qx > bx1) {
			if(qx > cx1) {
				var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
				var ii_max = Math.ceil(qx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx1);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
		} else if(bx1 > cx1) {
			var ii_min = qx > cx1 ? Math.floor(cx1) : Math.ceil(qx);
			var ii_max = Math.ceil(bx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		} else {
			var ii_min = Math.floor(qx);
			var ii_max = Math.ceil(cx1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			xIter3 = this1;
		}
		var yIter3;
		if(qy > by1) {
			if(qy > cy1) {
				var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
				var ii_max = Math.ceil(qy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by1);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
		} else if(by1 > cy1) {
			var ii_min = qy > cy1 ? Math.floor(cy1) : Math.ceil(qy);
			var ii_max = Math.ceil(by1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		} else {
			var ii_min = Math.floor(qy);
			var ii_max = Math.ceil(cy1);
			var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
			yIter3 = this1;
		}
		var undoImage = null;
		if(hasUndo) {
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy - pixelShape.virtualY) * pixelShape.width + dx - pixelShape.virtualX | 0 : dy * pixelShape.width + dx | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx - rectLeft;
						var y = dy - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
		}
		var found = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g_min = xIter3.start;
		var _g_max = xIter3.max;
		while(_g_min < _g_max) {
			var x = _g_min++;
			sxx = sx * x;
			txx = tx * x;
			found = false;
			var _g_min1 = yIter3.start;
			var _g_max1 = yIter3.max;
			while(_g_min1 < _g_max1) {
				var y = _g_min1++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(found) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					found = true;
				} else if(found) {
					break;
				}
			}
		}
		var hitTri;
		if(hasHit2 == true) {
			var v = new pixelimageXY_algo_HitTri(qx,qy,bx1,by1,cx1,cy1,true);
			if(hasUndo) {
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			hitTri = v;
		} else {
			hitTri = null;
		}
		if(hasHit) {
			var hitArr = new pixelimageXY_algo_HitTriArray([hitTri]);
			if(hitQuad != null) {
				hitArr.triArr.push(hitQuad.triABD);
			}
			hitArr.triArr.push(hitQuad.triBCD);
		}
		return pixelShape;
	}
	,__class__: pixelimageXY_triangleGML_ArrowShape
});
var triangleGML_shape_form_CircleForm_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter) {
	if(diameter == null) {
		diameter = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_FillForm.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.diameter = diameter;
};
triangleGML_shape_form_CircleForm_$.__name__ = "triangleGML.shape.form.CircleForm_";
triangleGML_shape_form_CircleForm_$.__super__ = triangleGML_FillForm;
triangleGML_shape_form_CircleForm_$.prototype = $extend(triangleGML_FillForm.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "diameter":
			this.diameter = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		default:
			triangleGML_FillForm.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: triangleGML_shape_form_CircleForm_$
});
var pixelimageXY_triangleGML_CircleForm = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter) {
	triangleGML_shape_form_CircleForm_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter);
};
pixelimageXY_triangleGML_CircleForm.__name__ = "pixelimageXY.triangleGML.CircleForm";
pixelimageXY_triangleGML_CircleForm.__super__ = triangleGML_shape_form_CircleForm_$;
pixelimageXY_triangleGML_CircleForm.prototype = $extend(triangleGML_shape_form_CircleForm_$.prototype,{
	render: function(pixelShape) {
		var w = Math.ceil(this.diameter);
		var h = Math.ceil(this.diameter);
		var this1 = new Uint32Array(w * h | 0);
		var this2 = new pixelimageXY_ImageStruct(w,h,this1);
		var this1 = this2;
		var temp = this1;
		temp.transparent = false;
		this.buildCircle(temp);
		var x = this.left + this.offX | 0;
		var y = this.top + this.offY | 0;
		var _g = 0;
		var _g1 = temp.height;
		while(_g < _g1) {
			var dy = _g++;
			var _g2 = 0;
			var _g3 = temp.width;
			while(_g2 < _g3) {
				var dx = _g2++;
				var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
				var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(temp.useMask && temp.mask != null) {
					var this1 = temp.mask;
					var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
					var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					var maskPixel = this2;
					var this3 = col;
					var this4 = this3;
					if(maskPixel == 0) {
						var this5 = this4;
						col = this5;
					} else {
						var this6 = maskPixel >> 24 & 255;
						var m0 = this6 == 0 ? 0. : this6 / 255;
						var this7 = maskPixel >> 16 & 255;
						var m1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = maskPixel >> 8 & 255;
						var m2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = maskPixel & 255;
						var m3 = this9 == 0 ? 0. : this9 / 255;
						var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
						var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
						var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
						var ch3 = (1. - m3) * (this4 & 255) | 0;
						col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
					}
				}
				if(col != 0) {
					var x1 = x + dx;
					var y1 = y + dy;
					var this10 = col;
					var c2 = this10;
					if((c2 >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0;
						var this11 = pixelShape.image[location];
						var this12 = this11;
						var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
						var this14 = this13 >> 24 & 255;
						var a1 = this14 == 0 ? 0. : this14 / 255;
						var this15 = this13 >> 16 & 255;
						var r1 = this15 == 0 ? 0. : this15 / 255;
						var this16 = this13 >> 8 & 255;
						var g1 = this16 == 0 ? 0. : this16 / 255;
						var this17 = this13 & 255;
						var b1 = this17 == 0 ? 0. : this17 / 255;
						var this18 = col >> 24 & 255;
						var a2 = this18 == 0 ? 0. : this18 / 255;
						var this19 = col >> 16 & 255;
						var r2 = this19 == 0 ? 0. : this19 / 255;
						var this20 = col >> 8 & 255;
						var g2 = this20 == 0 ? 0. : this20 / 255;
						var this21 = col & 255;
						var b2 = this21 == 0 ? 0. : this21 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					}
				}
			}
		}
		temp = null;
		return pixelShape;
	}
	,buildCircle: function(temp) {
		var w = Math.round(this.strokeWidth / 2);
		var r = this.diameter / 2;
		var innerR = this.diameter / 2 - 4 * w;
		var cx = this.diameter / 2;
		var cy = this.diameter / 2;
		var phi = 0.;
		var innerCx = cx - w / 4;
		var innerCy = cy - w / 4;
		var color = this.strokeColor;
		var phi1 = phi;
		if(phi1 == null) {
			phi1 = 0;
		}
		var rSmall = r > r ? r : r;
		var targetE = 1.05;
		if(targetE == null) {
			targetE = 1.05;
		}
		var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
		var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
		var phi2 = phi1;
		var sides = noSides;
		if(sides == null) {
			sides = 36;
		}
		if(phi2 == null) {
			phi2 = 0.;
		}
		var phi1 = phi2;
		var sides1 = sides;
		var cornerUp = true;
		if(cornerUp == null) {
			cornerUp = true;
		}
		if(sides1 == null) {
			sides1 = 36;
		}
		if(phi1 == null) {
			phi1 = 0.;
		}
		var theta = 2 * Math.PI / sides1;
		var omega;
		if(cornerUp) {
			omega = 0.;
		} else if((sides1 / 2 | 0) == sides1 / 2) {
			omega = Math.PI / sides1;
		} else {
			var v = sides1 / 2 - 0.5;
			omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
		}
		var lastX = 0.;
		var lastY = 0.;
		if(phi1 != 0) {
			lastX = r * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - r * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + cx;
			lastY = r * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + r * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + cy;
		} else {
			lastX = cx + r * Math.cos(sides1 * theta + omega);
			lastY = cy + r * Math.sin(sides1 * theta + omega);
		}
		if(phi1 != 0) {
			var cphi = Math.cos(phi1);
			var sphi = Math.sin(phi1);
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var stheta = Math.sin(i * theta + omega + 0.01);
				var ctheta = Math.cos(i * theta + omega + 0.01);
				var nextX = r * ctheta * cphi - r * stheta * sphi + cx;
				var nextY = r * ctheta * sphi + r * stheta * cphi + cy;
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx - rectLeft;
								var y = dy - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r3 << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x1 = _g_min++;
					sxx = sx * x1;
					txx = tx * x1;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y1 = _g_min1++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r4 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		} else {
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + r * Math.cos(i * theta + omega + 0.01);
				var nextY = cy + r * Math.sin(i * theta + omega + 0.01);
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx - rectLeft;
								var y = dy - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r3 << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x1 = _g_min++;
					sxx = sx * x1;
					txx = tx * x1;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y1 = _g_min1++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r4 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		}
		var color = this.fill;
		var phi1 = phi;
		if(phi1 == null) {
			phi1 = 0;
		}
		var rSmall = innerR > innerR ? innerR : innerR;
		var targetE = 1.05;
		if(targetE == null) {
			targetE = 1.05;
		}
		var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
		var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
		var phi = phi1;
		var sides = noSides;
		if(sides == null) {
			sides = 36;
		}
		if(phi == null) {
			phi = 0.;
		}
		var phi1 = phi;
		var sides1 = sides;
		var cornerUp = true;
		if(cornerUp == null) {
			cornerUp = true;
		}
		if(sides1 == null) {
			sides1 = 36;
		}
		if(phi1 == null) {
			phi1 = 0.;
		}
		var theta = 2 * Math.PI / sides1;
		var omega;
		if(cornerUp) {
			omega = 0.;
		} else if((sides1 / 2 | 0) == sides1 / 2) {
			omega = Math.PI / sides1;
		} else {
			var v = sides1 / 2 - 0.5;
			omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
		}
		var lastX = 0.;
		var lastY = 0.;
		if(phi1 != 0) {
			lastX = innerR * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - innerR * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + innerCx;
			lastY = innerR * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + innerR * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + innerCy;
		} else {
			lastX = innerCx + innerR * Math.cos(sides1 * theta + omega);
			lastY = innerCy + innerR * Math.sin(sides1 * theta + omega);
		}
		if(phi1 != 0) {
			var cphi = Math.cos(phi1);
			var sphi = Math.sin(phi1);
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var stheta = Math.sin(i * theta + omega + 0.01);
				var ctheta = Math.cos(i * theta + omega + 0.01);
				var nextX = innerR * ctheta * cphi - innerR * stheta * sphi + innerCx;
				var nextY = innerR * ctheta * sphi + innerR * stheta * cphi + innerCy;
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = innerCx * by - bx * innerCy + (bx * cy - cx * by) + (cx * innerCy - innerCx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = innerCy * cx - innerCx * cy;
				var sx = cy - innerCy;
				var sy = innerCx - cx;
				var t0 = innerCx * by - innerCy * bx;
				var tx = innerCy - by;
				var ty = bx - innerCx;
				var A = -by * cx + innerCy * (-bx + cx) + innerCx * (by - cy) + bx * cy;
				var xIter3;
				if(innerCx > bx) {
					if(innerCx > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(innerCx);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx) {
					var ii_min2 = innerCx > cx ? Math.floor(cx) : Math.ceil(innerCx);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(innerCx);
					var ii_max3 = Math.ceil(cx);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(innerCy > by) {
					if(innerCy > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(innerCy);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy) {
					var ii_min6 = innerCy > cy ? Math.floor(cy) : Math.ceil(innerCy);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(innerCy);
					var ii_max7 = Math.ceil(cy);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx - rectLeft;
								var y = dy - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x1 = _g_min++;
					sxx = sx * x1;
					txx = tx * x1;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y1 = _g_min1++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(innerCx,innerCy,bx,by,cx,cy,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		} else {
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = innerCx + innerR * Math.cos(i * theta + omega + 0.01);
				var nextY = innerCy + innerR * Math.sin(i * theta + omega + 0.01);
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = innerCx * by - bx * innerCy + (bx * cy - cx * by) + (cx * innerCy - innerCx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = innerCy * cx - innerCx * cy;
				var sx = cy - innerCy;
				var sy = innerCx - cx;
				var t0 = innerCx * by - innerCy * bx;
				var tx = innerCy - by;
				var ty = bx - innerCx;
				var A = -by * cx + innerCy * (-bx + cx) + innerCx * (by - cy) + bx * cy;
				var xIter3;
				if(innerCx > bx) {
					if(innerCx > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(innerCx);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx) {
					var ii_min2 = innerCx > cx ? Math.floor(cx) : Math.ceil(innerCx);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(innerCx);
					var ii_max3 = Math.ceil(cx);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(innerCy > by) {
					if(innerCy > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(innerCy);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy) {
					var ii_min6 = innerCy > cy ? Math.floor(cy) : Math.ceil(innerCy);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(innerCy);
					var ii_max7 = Math.ceil(cy);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx - rectLeft;
								var y = dy - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x1 = _g_min++;
					sxx = sx * x1;
					txx = tx * x1;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y1 = _g_min1++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(innerCx,innerCy,bx,by,cx,cy,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		}
	}
	,__class__: pixelimageXY_triangleGML_CircleForm
});
var triangleGML_shape_form_EllipseForm_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height) {
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_FillForm.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
};
triangleGML_shape_form_EllipseForm_$.__name__ = "triangleGML.shape.form.EllipseForm_";
triangleGML_shape_form_EllipseForm_$.__super__ = triangleGML_FillForm;
triangleGML_shape_form_EllipseForm_$.prototype = $extend(triangleGML_FillForm.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			triangleGML_FillForm.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: triangleGML_shape_form_EllipseForm_$
});
var pixelimageXY_triangleGML_EllipseForm = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height) {
	triangleGML_shape_form_EllipseForm_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height);
};
pixelimageXY_triangleGML_EllipseForm.__name__ = "pixelimageXY.triangleGML.EllipseForm";
pixelimageXY_triangleGML_EllipseForm.__super__ = triangleGML_shape_form_EllipseForm_$;
pixelimageXY_triangleGML_EllipseForm.prototype = $extend(triangleGML_shape_form_EllipseForm_$.prototype,{
	render: function(pixelShape) {
		var w = Math.ceil(this.width);
		var h = Math.ceil(this.height);
		var this1 = new Uint32Array(w * h | 0);
		var this2 = new pixelimageXY_ImageStruct(w,h,this1);
		var this1 = this2;
		var temp = this1;
		temp.transparent = false;
		var rW = this.width / 2;
		var rH = this.height / 2;
		var innerRw = rW - this.strokeWidth / 2;
		var innerRh = rH - this.strokeWidth / 2;
		var cx = rW;
		var cy = rH;
		var phi = 0;
		var innerCx = cx + this.strokeWidth;
		var innerCy = cy + this.strokeWidth;
		if(this.edgeSoft == 0.) {
			var color = this.strokeColor;
			var phi1 = phi;
			if(phi1 == null) {
				phi1 = 0;
			}
			var rSmall = rW > rH ? rH : rW;
			var targetE = 1.05;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var phi2 = phi1;
			var sides = noSides;
			if(sides == null) {
				sides = 36;
			}
			if(phi2 == null) {
				phi2 = 0.;
			}
			var phi1 = phi2;
			var sides1 = sides;
			var cornerUp = true;
			if(cornerUp == null) {
				cornerUp = true;
			}
			if(sides1 == null) {
				sides1 = 36;
			}
			if(phi1 == null) {
				phi1 = 0.;
			}
			var theta = 2 * Math.PI / sides1;
			var omega;
			if(cornerUp) {
				omega = 0.;
			} else if((sides1 / 2 | 0) == sides1 / 2) {
				omega = Math.PI / sides1;
			} else {
				var v = sides1 / 2 - 0.5;
				omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
			}
			var lastX = 0.;
			var lastY = 0.;
			if(phi1 != 0) {
				lastX = rW * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - rH * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + cx;
				lastY = rW * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + rH * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + cy;
			} else {
				lastX = cx + rW * Math.cos(sides1 * theta + omega);
				lastY = cy + rH * Math.sin(sides1 * theta + omega);
			}
			if(phi1 != 0) {
				var cphi = Math.cos(phi1);
				var sphi = Math.sin(phi1);
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var stheta = Math.sin(i * theta + omega + 0.01);
					var ctheta = Math.cos(i * theta + omega + 0.01);
					var nextX = rW * ctheta * cphi - rH * stheta * sphi + cx;
					var nextY = rW * ctheta * sphi + rH * stheta * cphi + cy;
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var hasHit = false;
					var hasUndo = false;
					if(hasUndo == null) {
						hasUndo = false;
					}
					if(hasHit == null) {
						hasHit = false;
					}
					var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var hasHit1 = hasHit;
					var hasUndo1 = hasUndo;
					if(hasUndo1 == null) {
						hasUndo1 = false;
					}
					if(hasHit1 == null) {
						hasHit1 = false;
					}
					var s0 = cy * cx1 - cx * cy1;
					var sx = cy1 - cy;
					var sy = cx - cx1;
					var t0 = cx * by - cy * bx;
					var tx = cy - by;
					var ty = bx - cx;
					var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
					var xIter3;
					if(cx > bx) {
						if(cx > cx1) {
							var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
							var ii_max = Math.ceil(cx);
							var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this1;
						} else {
							var ii_min1 = Math.floor(bx);
							var ii_max1 = Math.ceil(cx1);
							var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this2;
						}
					} else if(bx > cx1) {
						var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
						var ii_max2 = Math.ceil(bx);
						var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this3;
					} else {
						var ii_min3 = Math.floor(cx);
						var ii_max3 = Math.ceil(cx1);
						var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this4;
					}
					var yIter3;
					if(cy > by) {
						if(cy > cy1) {
							var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
							var ii_max4 = Math.ceil(cy);
							var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this5;
						} else {
							var ii_min5 = Math.floor(by);
							var ii_max5 = Math.ceil(cy1);
							var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this6;
						}
					} else if(by > cy1) {
						var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
						var ii_max6 = Math.ceil(by);
						var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this7;
					} else {
						var ii_min7 = Math.floor(cy);
						var ii_max7 = Math.ceil(cy1);
						var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this8;
					}
					var undoImage = null;
					if(hasUndo1) {
						var w = xIter3.max - xIter3.start + 1;
						var h = yIter3.max - yIter3.start + 1;
						var this9 = new Uint32Array(w * h | 0);
						var this10 = new pixelimageXY_ImageStruct(w,h,this9);
						undoImage = this10;
						var rectLeft = xIter3.start;
						var rectTop = yIter3.start;
						var rectRight = xIter3.max;
						var _g2 = rectTop;
						var _g3 = yIter3.max;
						while(_g2 < _g3) {
							var dy = _g2++;
							var _g4 = rectLeft;
							var _g5 = rectRight;
							while(_g4 < _g5) {
								var dx = _g4++;
								var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
								var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
								if(temp.useMask && temp.mask != null) {
									var this11 = temp.mask;
									var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
									var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
									var maskPixel = this12;
									var this13 = col;
									var this14 = this13;
									if(maskPixel == 0) {
										var this15 = this14;
										col = this15;
									} else {
										var this16 = maskPixel >> 24 & 255;
										var m0 = this16 == 0 ? 0. : this16 / 255;
										var this17 = maskPixel >> 16 & 255;
										var m1 = this17 == 0 ? 0. : this17 / 255;
										var this18 = maskPixel >> 8 & 255;
										var m2 = this18 == 0 ? 0. : this18 / 255;
										var this19 = maskPixel & 255;
										var m3 = this19 == 0 ? 0. : this19 / 255;
										var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
										var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
										var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
										var ch3 = (1. - m3) * (this14 & 255) | 0;
										col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
									}
								}
								if(col != 0) {
									var x = dx - rectLeft;
									var y = dy - rectTop;
									var this20 = col;
									var c2 = this20;
									if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
										var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
										var this21 = undoImage.image[location];
										var this22 = this21;
										var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
										var this24 = this23 >> 24 & 255;
										var a1 = this24 == 0 ? 0. : this24 / 255;
										var this25 = this23 >> 16 & 255;
										var r1 = this25 == 0 ? 0. : this25 / 255;
										var this26 = this23 >> 8 & 255;
										var g1 = this26 == 0 ? 0. : this26 / 255;
										var this27 = this23 & 255;
										var b1 = this27 == 0 ? 0. : this27 / 255;
										var this28 = col >> 24 & 255;
										var a2 = this28 == 0 ? 0. : this28 / 255;
										var this29 = col >> 16 & 255;
										var r2 = this29 == 0 ? 0. : this29 / 255;
										var this30 = col >> 8 & 255;
										var g2 = this30 == 0 ? 0. : this30 / 255;
										var this31 = col & 255;
										var b2 = this31 == 0 ? 0. : this31 / 255;
										var a3 = a1 * (1 - a2);
										var r = 255 * (r1 * a3 + r2 * a2) | 0;
										var g = 255 * (g1 * a3 + g2 * a2) | 0;
										var b = 255 * (b1 * a3 + b2 * a2) | 0;
										var a = 255 * (a3 + a2) | 0;
										var blended = a << 24 | r << 16 | g << 8 | b;
										undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
									} else {
										undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
									}
								}
							}
						}
					}
					var found = false;
					var s = 0.;
					var t = 0.;
					var sxx = 0.;
					var txx = 0.;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var x1 = _g_min++;
						sxx = sx * x1;
						txx = tx * x1;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var y1 = _g_min1++;
							s = s0 + sxx + sy * y1;
							t = t0 + txx + ty * y1;
							if(s <= 0 || t <= 0) {
								if(found) {
									break;
								}
							} else if(s + t < A) {
								var this32 = color;
								var c3 = this32;
								if((c3 >> 24 & 255) < 254 && temp.transparent) {
									var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
									var this33 = temp.image[location1];
									var this34 = this33;
									var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
									var this36 = this35 >> 24 & 255;
									var a11 = this36 == 0 ? 0. : this36 / 255;
									var this37 = this35 >> 16 & 255;
									var r11 = this37 == 0 ? 0. : this37 / 255;
									var this38 = this35 >> 8 & 255;
									var g11 = this38 == 0 ? 0. : this38 / 255;
									var this39 = this35 & 255;
									var b11 = this39 == 0 ? 0. : this39 / 255;
									var this40 = color >> 24 & 255;
									var a21 = this40 == 0 ? 0. : this40 / 255;
									var this41 = color >> 16 & 255;
									var r21 = this41 == 0 ? 0. : this41 / 255;
									var this42 = color >> 8 & 255;
									var g21 = this42 == 0 ? 0. : this42 / 255;
									var this43 = color & 255;
									var b21 = this43 == 0 ? 0. : this43 / 255;
									var a31 = a11 * (1 - a21);
									var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
									var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
									var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
									var a4 = 255 * (a31 + a21) | 0;
									var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
								} else {
									temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					if(hasHit1 == true) {
						var v = new pixelimageXY_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
						if(hasUndo1) {
							v.undoImage = undoImage;
							v.undoX = xIter3.start;
							v.undoY = yIter3.start;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			} else {
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var nextX = cx + rW * Math.cos(i * theta + omega + 0.01);
					var nextY = cy + rH * Math.sin(i * theta + omega + 0.01);
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var hasHit = false;
					var hasUndo = false;
					if(hasUndo == null) {
						hasUndo = false;
					}
					if(hasHit == null) {
						hasHit = false;
					}
					var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var hasHit1 = hasHit;
					var hasUndo1 = hasUndo;
					if(hasUndo1 == null) {
						hasUndo1 = false;
					}
					if(hasHit1 == null) {
						hasHit1 = false;
					}
					var s0 = cy * cx1 - cx * cy1;
					var sx = cy1 - cy;
					var sy = cx - cx1;
					var t0 = cx * by - cy * bx;
					var tx = cy - by;
					var ty = bx - cx;
					var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
					var xIter3;
					if(cx > bx) {
						if(cx > cx1) {
							var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
							var ii_max = Math.ceil(cx);
							var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this1;
						} else {
							var ii_min1 = Math.floor(bx);
							var ii_max1 = Math.ceil(cx1);
							var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this2;
						}
					} else if(bx > cx1) {
						var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
						var ii_max2 = Math.ceil(bx);
						var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this3;
					} else {
						var ii_min3 = Math.floor(cx);
						var ii_max3 = Math.ceil(cx1);
						var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this4;
					}
					var yIter3;
					if(cy > by) {
						if(cy > cy1) {
							var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
							var ii_max4 = Math.ceil(cy);
							var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this5;
						} else {
							var ii_min5 = Math.floor(by);
							var ii_max5 = Math.ceil(cy1);
							var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this6;
						}
					} else if(by > cy1) {
						var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
						var ii_max6 = Math.ceil(by);
						var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this7;
					} else {
						var ii_min7 = Math.floor(cy);
						var ii_max7 = Math.ceil(cy1);
						var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this8;
					}
					var undoImage = null;
					if(hasUndo1) {
						var w = xIter3.max - xIter3.start + 1;
						var h = yIter3.max - yIter3.start + 1;
						var this9 = new Uint32Array(w * h | 0);
						var this10 = new pixelimageXY_ImageStruct(w,h,this9);
						undoImage = this10;
						var rectLeft = xIter3.start;
						var rectTop = yIter3.start;
						var rectRight = xIter3.max;
						var _g2 = rectTop;
						var _g3 = yIter3.max;
						while(_g2 < _g3) {
							var dy = _g2++;
							var _g4 = rectLeft;
							var _g5 = rectRight;
							while(_g4 < _g5) {
								var dx = _g4++;
								var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
								var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
								if(temp.useMask && temp.mask != null) {
									var this11 = temp.mask;
									var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
									var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
									var maskPixel = this12;
									var this13 = col;
									var this14 = this13;
									if(maskPixel == 0) {
										var this15 = this14;
										col = this15;
									} else {
										var this16 = maskPixel >> 24 & 255;
										var m0 = this16 == 0 ? 0. : this16 / 255;
										var this17 = maskPixel >> 16 & 255;
										var m1 = this17 == 0 ? 0. : this17 / 255;
										var this18 = maskPixel >> 8 & 255;
										var m2 = this18 == 0 ? 0. : this18 / 255;
										var this19 = maskPixel & 255;
										var m3 = this19 == 0 ? 0. : this19 / 255;
										var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
										var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
										var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
										var ch3 = (1. - m3) * (this14 & 255) | 0;
										col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
									}
								}
								if(col != 0) {
									var x = dx - rectLeft;
									var y = dy - rectTop;
									var this20 = col;
									var c2 = this20;
									if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
										var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
										var this21 = undoImage.image[location];
										var this22 = this21;
										var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
										var this24 = this23 >> 24 & 255;
										var a1 = this24 == 0 ? 0. : this24 / 255;
										var this25 = this23 >> 16 & 255;
										var r1 = this25 == 0 ? 0. : this25 / 255;
										var this26 = this23 >> 8 & 255;
										var g1 = this26 == 0 ? 0. : this26 / 255;
										var this27 = this23 & 255;
										var b1 = this27 == 0 ? 0. : this27 / 255;
										var this28 = col >> 24 & 255;
										var a2 = this28 == 0 ? 0. : this28 / 255;
										var this29 = col >> 16 & 255;
										var r2 = this29 == 0 ? 0. : this29 / 255;
										var this30 = col >> 8 & 255;
										var g2 = this30 == 0 ? 0. : this30 / 255;
										var this31 = col & 255;
										var b2 = this31 == 0 ? 0. : this31 / 255;
										var a3 = a1 * (1 - a2);
										var r = 255 * (r1 * a3 + r2 * a2) | 0;
										var g = 255 * (g1 * a3 + g2 * a2) | 0;
										var b = 255 * (b1 * a3 + b2 * a2) | 0;
										var a = 255 * (a3 + a2) | 0;
										var blended = a << 24 | r << 16 | g << 8 | b;
										undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
									} else {
										undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
									}
								}
							}
						}
					}
					var found = false;
					var s = 0.;
					var t = 0.;
					var sxx = 0.;
					var txx = 0.;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var x1 = _g_min++;
						sxx = sx * x1;
						txx = tx * x1;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var y1 = _g_min1++;
							s = s0 + sxx + sy * y1;
							t = t0 + txx + ty * y1;
							if(s <= 0 || t <= 0) {
								if(found) {
									break;
								}
							} else if(s + t < A) {
								var this32 = color;
								var c3 = this32;
								if((c3 >> 24 & 255) < 254 && temp.transparent) {
									var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
									var this33 = temp.image[location1];
									var this34 = this33;
									var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
									var this36 = this35 >> 24 & 255;
									var a11 = this36 == 0 ? 0. : this36 / 255;
									var this37 = this35 >> 16 & 255;
									var r11 = this37 == 0 ? 0. : this37 / 255;
									var this38 = this35 >> 8 & 255;
									var g11 = this38 == 0 ? 0. : this38 / 255;
									var this39 = this35 & 255;
									var b11 = this39 == 0 ? 0. : this39 / 255;
									var this40 = color >> 24 & 255;
									var a21 = this40 == 0 ? 0. : this40 / 255;
									var this41 = color >> 16 & 255;
									var r21 = this41 == 0 ? 0. : this41 / 255;
									var this42 = color >> 8 & 255;
									var g21 = this42 == 0 ? 0. : this42 / 255;
									var this43 = color & 255;
									var b21 = this43 == 0 ? 0. : this43 / 255;
									var a31 = a11 * (1 - a21);
									var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
									var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
									var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
									var a4 = 255 * (a31 + a21) | 0;
									var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
								} else {
									temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					if(hasHit1 == true) {
						var v = new pixelimageXY_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
						if(hasUndo1) {
							v.undoImage = undoImage;
							v.undoX = xIter3.start;
							v.undoY = yIter3.start;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			}
			var color = this.fill;
			var phi1 = phi;
			if(phi1 == null) {
				phi1 = 0;
			}
			var rSmall = innerRw > innerRh ? innerRh : innerRw;
			var targetE = 1.05;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var phi2 = phi1;
			var sides = noSides;
			if(sides == null) {
				sides = 36;
			}
			if(phi2 == null) {
				phi2 = 0.;
			}
			var phi1 = phi2;
			var sides1 = sides;
			var cornerUp = true;
			if(cornerUp == null) {
				cornerUp = true;
			}
			if(sides1 == null) {
				sides1 = 36;
			}
			if(phi1 == null) {
				phi1 = 0.;
			}
			var theta = 2 * Math.PI / sides1;
			var omega;
			if(cornerUp) {
				omega = 0.;
			} else if((sides1 / 2 | 0) == sides1 / 2) {
				omega = Math.PI / sides1;
			} else {
				var v = sides1 / 2 - 0.5;
				omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
			}
			var lastX = 0.;
			var lastY = 0.;
			if(phi1 != 0) {
				lastX = innerRw * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - innerRh * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + innerCx;
				lastY = innerRw * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + innerRh * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + innerCy;
			} else {
				lastX = innerCx + innerRw * Math.cos(sides1 * theta + omega);
				lastY = innerCy + innerRh * Math.sin(sides1 * theta + omega);
			}
			if(phi1 != 0) {
				var cphi = Math.cos(phi1);
				var sphi = Math.sin(phi1);
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var stheta = Math.sin(i * theta + omega + 0.01);
					var ctheta = Math.cos(i * theta + omega + 0.01);
					var nextX = innerRw * ctheta * cphi - innerRh * stheta * sphi + innerCx;
					var nextY = innerRw * ctheta * sphi + innerRh * stheta * cphi + innerCy;
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var hasHit = false;
					var hasUndo = false;
					if(hasUndo == null) {
						hasUndo = false;
					}
					if(hasHit == null) {
						hasHit = false;
					}
					var adjustWinding = innerCx * by - bx * innerCy + (bx * cy1 - cx1 * by) + (cx1 * innerCy - innerCx * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var hasHit1 = hasHit;
					var hasUndo1 = hasUndo;
					if(hasUndo1 == null) {
						hasUndo1 = false;
					}
					if(hasHit1 == null) {
						hasHit1 = false;
					}
					var s0 = innerCy * cx1 - innerCx * cy1;
					var sx = cy1 - innerCy;
					var sy = innerCx - cx1;
					var t0 = innerCx * by - innerCy * bx;
					var tx = innerCy - by;
					var ty = bx - innerCx;
					var A = -by * cx1 + innerCy * (-bx + cx1) + innerCx * (by - cy1) + bx * cy1;
					var xIter3;
					if(innerCx > bx) {
						if(innerCx > cx1) {
							var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
							var ii_max = Math.ceil(innerCx);
							var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this1;
						} else {
							var ii_min1 = Math.floor(bx);
							var ii_max1 = Math.ceil(cx1);
							var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this2;
						}
					} else if(bx > cx1) {
						var ii_min2 = innerCx > cx1 ? Math.floor(cx1) : Math.ceil(innerCx);
						var ii_max2 = Math.ceil(bx);
						var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this3;
					} else {
						var ii_min3 = Math.floor(innerCx);
						var ii_max3 = Math.ceil(cx1);
						var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this4;
					}
					var yIter3;
					if(innerCy > by) {
						if(innerCy > cy1) {
							var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
							var ii_max4 = Math.ceil(innerCy);
							var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this5;
						} else {
							var ii_min5 = Math.floor(by);
							var ii_max5 = Math.ceil(cy1);
							var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this6;
						}
					} else if(by > cy1) {
						var ii_min6 = innerCy > cy1 ? Math.floor(cy1) : Math.ceil(innerCy);
						var ii_max6 = Math.ceil(by);
						var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this7;
					} else {
						var ii_min7 = Math.floor(innerCy);
						var ii_max7 = Math.ceil(cy1);
						var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this8;
					}
					var undoImage = null;
					if(hasUndo1) {
						var w = xIter3.max - xIter3.start + 1;
						var h = yIter3.max - yIter3.start + 1;
						var this9 = new Uint32Array(w * h | 0);
						var this10 = new pixelimageXY_ImageStruct(w,h,this9);
						undoImage = this10;
						var rectLeft = xIter3.start;
						var rectTop = yIter3.start;
						var rectRight = xIter3.max;
						var _g2 = rectTop;
						var _g3 = yIter3.max;
						while(_g2 < _g3) {
							var dy = _g2++;
							var _g4 = rectLeft;
							var _g5 = rectRight;
							while(_g4 < _g5) {
								var dx = _g4++;
								var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
								var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
								if(temp.useMask && temp.mask != null) {
									var this11 = temp.mask;
									var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
									var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
									var maskPixel = this12;
									var this13 = col;
									var this14 = this13;
									if(maskPixel == 0) {
										var this15 = this14;
										col = this15;
									} else {
										var this16 = maskPixel >> 24 & 255;
										var m0 = this16 == 0 ? 0. : this16 / 255;
										var this17 = maskPixel >> 16 & 255;
										var m1 = this17 == 0 ? 0. : this17 / 255;
										var this18 = maskPixel >> 8 & 255;
										var m2 = this18 == 0 ? 0. : this18 / 255;
										var this19 = maskPixel & 255;
										var m3 = this19 == 0 ? 0. : this19 / 255;
										var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
										var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
										var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
										var ch3 = (1. - m3) * (this14 & 255) | 0;
										col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
									}
								}
								if(col != 0) {
									var x = dx - rectLeft;
									var y = dy - rectTop;
									var this20 = col;
									var c2 = this20;
									if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
										var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
										var this21 = undoImage.image[location];
										var this22 = this21;
										var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
										var this24 = this23 >> 24 & 255;
										var a1 = this24 == 0 ? 0. : this24 / 255;
										var this25 = this23 >> 16 & 255;
										var r1 = this25 == 0 ? 0. : this25 / 255;
										var this26 = this23 >> 8 & 255;
										var g1 = this26 == 0 ? 0. : this26 / 255;
										var this27 = this23 & 255;
										var b1 = this27 == 0 ? 0. : this27 / 255;
										var this28 = col >> 24 & 255;
										var a2 = this28 == 0 ? 0. : this28 / 255;
										var this29 = col >> 16 & 255;
										var r2 = this29 == 0 ? 0. : this29 / 255;
										var this30 = col >> 8 & 255;
										var g2 = this30 == 0 ? 0. : this30 / 255;
										var this31 = col & 255;
										var b2 = this31 == 0 ? 0. : this31 / 255;
										var a3 = a1 * (1 - a2);
										var r = 255 * (r1 * a3 + r2 * a2) | 0;
										var g = 255 * (g1 * a3 + g2 * a2) | 0;
										var b = 255 * (b1 * a3 + b2 * a2) | 0;
										var a = 255 * (a3 + a2) | 0;
										var blended = a << 24 | r << 16 | g << 8 | b;
										undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
									} else {
										undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
									}
								}
							}
						}
					}
					var found = false;
					var s = 0.;
					var t = 0.;
					var sxx = 0.;
					var txx = 0.;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var x1 = _g_min++;
						sxx = sx * x1;
						txx = tx * x1;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var y1 = _g_min1++;
							s = s0 + sxx + sy * y1;
							t = t0 + txx + ty * y1;
							if(s <= 0 || t <= 0) {
								if(found) {
									break;
								}
							} else if(s + t < A) {
								var this32 = color;
								var c3 = this32;
								if((c3 >> 24 & 255) < 254 && temp.transparent) {
									var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
									var this33 = temp.image[location1];
									var this34 = this33;
									var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
									var this36 = this35 >> 24 & 255;
									var a11 = this36 == 0 ? 0. : this36 / 255;
									var this37 = this35 >> 16 & 255;
									var r11 = this37 == 0 ? 0. : this37 / 255;
									var this38 = this35 >> 8 & 255;
									var g11 = this38 == 0 ? 0. : this38 / 255;
									var this39 = this35 & 255;
									var b11 = this39 == 0 ? 0. : this39 / 255;
									var this40 = color >> 24 & 255;
									var a21 = this40 == 0 ? 0. : this40 / 255;
									var this41 = color >> 16 & 255;
									var r21 = this41 == 0 ? 0. : this41 / 255;
									var this42 = color >> 8 & 255;
									var g21 = this42 == 0 ? 0. : this42 / 255;
									var this43 = color & 255;
									var b21 = this43 == 0 ? 0. : this43 / 255;
									var a31 = a11 * (1 - a21);
									var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
									var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
									var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
									var a4 = 255 * (a31 + a21) | 0;
									var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
								} else {
									temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					if(hasHit1 == true) {
						var v = new pixelimageXY_algo_HitTri(innerCx,innerCy,bx,by,cx1,cy1,true);
						if(hasUndo1) {
							v.undoImage = undoImage;
							v.undoX = xIter3.start;
							v.undoY = yIter3.start;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			} else {
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var nextX = innerCx + innerRw * Math.cos(i * theta + omega + 0.01);
					var nextY = innerCy + innerRh * Math.sin(i * theta + omega + 0.01);
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var hasHit = false;
					var hasUndo = false;
					if(hasUndo == null) {
						hasUndo = false;
					}
					if(hasHit == null) {
						hasHit = false;
					}
					var adjustWinding = innerCx * by - bx * innerCy + (bx * cy1 - cx1 * by) + (cx1 * innerCy - innerCx * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var hasHit1 = hasHit;
					var hasUndo1 = hasUndo;
					if(hasUndo1 == null) {
						hasUndo1 = false;
					}
					if(hasHit1 == null) {
						hasHit1 = false;
					}
					var s0 = innerCy * cx1 - innerCx * cy1;
					var sx = cy1 - innerCy;
					var sy = innerCx - cx1;
					var t0 = innerCx * by - innerCy * bx;
					var tx = innerCy - by;
					var ty = bx - innerCx;
					var A = -by * cx1 + innerCy * (-bx + cx1) + innerCx * (by - cy1) + bx * cy1;
					var xIter3;
					if(innerCx > bx) {
						if(innerCx > cx1) {
							var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
							var ii_max = Math.ceil(innerCx);
							var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this1;
						} else {
							var ii_min1 = Math.floor(bx);
							var ii_max1 = Math.ceil(cx1);
							var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this2;
						}
					} else if(bx > cx1) {
						var ii_min2 = innerCx > cx1 ? Math.floor(cx1) : Math.ceil(innerCx);
						var ii_max2 = Math.ceil(bx);
						var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this3;
					} else {
						var ii_min3 = Math.floor(innerCx);
						var ii_max3 = Math.ceil(cx1);
						var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this4;
					}
					var yIter3;
					if(innerCy > by) {
						if(innerCy > cy1) {
							var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
							var ii_max4 = Math.ceil(innerCy);
							var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this5;
						} else {
							var ii_min5 = Math.floor(by);
							var ii_max5 = Math.ceil(cy1);
							var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this6;
						}
					} else if(by > cy1) {
						var ii_min6 = innerCy > cy1 ? Math.floor(cy1) : Math.ceil(innerCy);
						var ii_max6 = Math.ceil(by);
						var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this7;
					} else {
						var ii_min7 = Math.floor(innerCy);
						var ii_max7 = Math.ceil(cy1);
						var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this8;
					}
					var undoImage = null;
					if(hasUndo1) {
						var w = xIter3.max - xIter3.start + 1;
						var h = yIter3.max - yIter3.start + 1;
						var this9 = new Uint32Array(w * h | 0);
						var this10 = new pixelimageXY_ImageStruct(w,h,this9);
						undoImage = this10;
						var rectLeft = xIter3.start;
						var rectTop = yIter3.start;
						var rectRight = xIter3.max;
						var _g2 = rectTop;
						var _g3 = yIter3.max;
						while(_g2 < _g3) {
							var dy = _g2++;
							var _g4 = rectLeft;
							var _g5 = rectRight;
							while(_g4 < _g5) {
								var dx = _g4++;
								var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
								var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
								if(temp.useMask && temp.mask != null) {
									var this11 = temp.mask;
									var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
									var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
									var maskPixel = this12;
									var this13 = col;
									var this14 = this13;
									if(maskPixel == 0) {
										var this15 = this14;
										col = this15;
									} else {
										var this16 = maskPixel >> 24 & 255;
										var m0 = this16 == 0 ? 0. : this16 / 255;
										var this17 = maskPixel >> 16 & 255;
										var m1 = this17 == 0 ? 0. : this17 / 255;
										var this18 = maskPixel >> 8 & 255;
										var m2 = this18 == 0 ? 0. : this18 / 255;
										var this19 = maskPixel & 255;
										var m3 = this19 == 0 ? 0. : this19 / 255;
										var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
										var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
										var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
										var ch3 = (1. - m3) * (this14 & 255) | 0;
										col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
									}
								}
								if(col != 0) {
									var x = dx - rectLeft;
									var y = dy - rectTop;
									var this20 = col;
									var c2 = this20;
									if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
										var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
										var this21 = undoImage.image[location];
										var this22 = this21;
										var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
										var this24 = this23 >> 24 & 255;
										var a1 = this24 == 0 ? 0. : this24 / 255;
										var this25 = this23 >> 16 & 255;
										var r1 = this25 == 0 ? 0. : this25 / 255;
										var this26 = this23 >> 8 & 255;
										var g1 = this26 == 0 ? 0. : this26 / 255;
										var this27 = this23 & 255;
										var b1 = this27 == 0 ? 0. : this27 / 255;
										var this28 = col >> 24 & 255;
										var a2 = this28 == 0 ? 0. : this28 / 255;
										var this29 = col >> 16 & 255;
										var r2 = this29 == 0 ? 0. : this29 / 255;
										var this30 = col >> 8 & 255;
										var g2 = this30 == 0 ? 0. : this30 / 255;
										var this31 = col & 255;
										var b2 = this31 == 0 ? 0. : this31 / 255;
										var a3 = a1 * (1 - a2);
										var r = 255 * (r1 * a3 + r2 * a2) | 0;
										var g = 255 * (g1 * a3 + g2 * a2) | 0;
										var b = 255 * (b1 * a3 + b2 * a2) | 0;
										var a = 255 * (a3 + a2) | 0;
										var blended = a << 24 | r << 16 | g << 8 | b;
										undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
									} else {
										undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
									}
								}
							}
						}
					}
					var found = false;
					var s = 0.;
					var t = 0.;
					var sxx = 0.;
					var txx = 0.;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var x1 = _g_min++;
						sxx = sx * x1;
						txx = tx * x1;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var y1 = _g_min1++;
							s = s0 + sxx + sy * y1;
							t = t0 + txx + ty * y1;
							if(s <= 0 || t <= 0) {
								if(found) {
									break;
								}
							} else if(s + t < A) {
								var this32 = color;
								var c3 = this32;
								if((c3 >> 24 & 255) < 254 && temp.transparent) {
									var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
									var this33 = temp.image[location1];
									var this34 = this33;
									var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
									var this36 = this35 >> 24 & 255;
									var a11 = this36 == 0 ? 0. : this36 / 255;
									var this37 = this35 >> 16 & 255;
									var r11 = this37 == 0 ? 0. : this37 / 255;
									var this38 = this35 >> 8 & 255;
									var g11 = this38 == 0 ? 0. : this38 / 255;
									var this39 = this35 & 255;
									var b11 = this39 == 0 ? 0. : this39 / 255;
									var this40 = color >> 24 & 255;
									var a21 = this40 == 0 ? 0. : this40 / 255;
									var this41 = color >> 16 & 255;
									var r21 = this41 == 0 ? 0. : this41 / 255;
									var this42 = color >> 8 & 255;
									var g21 = this42 == 0 ? 0. : this42 / 255;
									var this43 = color & 255;
									var b21 = this43 == 0 ? 0. : this43 / 255;
									var a31 = a11 * (1 - a21);
									var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
									var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
									var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
									var a4 = 255 * (a31 + a21) | 0;
									var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
								} else {
									temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					if(hasHit1 == true) {
						var v = new pixelimageXY_algo_HitTri(innerCx,innerCy,bx,by,cx1,cy1,true);
						if(hasUndo1) {
							v.undoImage = undoImage;
							v.undoX = xIter3.start;
							v.undoY = yIter3.start;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			}
		} else {
			var color = this.strokeColor;
			var phi1 = phi;
			var softC = this.edgeSoft;
			if(softC == null) {
				softC = 10;
			}
			if(phi1 == null) {
				phi1 = 0;
			}
			var rSmall = rW > rH ? rH : rW;
			var targetE = 1.05;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var phi2 = phi1;
			var sides = noSides;
			var softC1 = softC;
			if(softC1 == null) {
				softC1 = 10.;
			}
			if(sides == null) {
				sides = 36;
			}
			if(phi2 == null) {
				phi2 = 0.;
			}
			var phi1 = phi2;
			var sides1 = sides;
			var softC = softC1;
			var cornerUp = true;
			if(cornerUp == null) {
				cornerUp = true;
			}
			if(softC == null) {
				softC = 10;
			}
			if(sides1 == null) {
				sides1 = 36;
			}
			if(phi1 == null) {
				phi1 = 0.;
			}
			var theta = 2 * Math.PI / sides1;
			var omega;
			if(cornerUp) {
				omega = 0.;
			} else if((sides1 / 2 | 0) == sides1 / 2) {
				omega = Math.PI / sides1;
			} else {
				var v = sides1 / 2 - 0.5;
				omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
			}
			var lastX = 0.;
			var lastY = 0.;
			if(phi1 != 0) {
				lastX = rW * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - rH * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + cx;
				lastY = rW * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + rH * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + cy;
			} else {
				lastX = cx + rW * Math.cos(sides1 * theta + omega);
				lastY = cy + rH * Math.sin(sides1 * theta + omega);
			}
			if(phi1 != 0) {
				var cphi = Math.cos(phi1);
				var sphi = Math.sin(phi1);
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var stheta = Math.sin(i * theta + omega + 0.01);
					var ctheta = Math.cos(i * theta + omega + 0.01);
					var nextX = rW * ctheta * cphi - rH * stheta * sphi + cx;
					var nextY = rW * ctheta * sphi + rH * stheta * cphi + cy;
					var softC1 = softC;
					if(softC1 == null) {
						softC1 = 10;
					}
					var aA = color >> 24 & 255;
					var rA = color >> 16 & 255;
					var gA = color >> 8 & 255;
					var bA = color & 255;
					var bcx = lastX - nextX;
					var bcy = lastY - nextY;
					var acx = cx - nextX;
					var acy = cy - nextY;
					var dot11 = bcx * bcx + bcy * bcy;
					var dot12 = bcx * acx + bcy * acy;
					var dot22 = acx * acx + acy * acy;
					var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
					var xIter3;
					if(cx > lastX) {
						if(cx > nextX) {
							var ii_min = lastX > nextX ? Math.floor(nextX) : Math.floor(lastX);
							var ii_max = Math.ceil(cx);
							var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this1;
						} else {
							var ii_min1 = Math.floor(lastX);
							var ii_max1 = Math.ceil(nextX);
							var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this2;
						}
					} else if(lastX > nextX) {
						var ii_min2 = cx > nextX ? Math.floor(nextX) : Math.ceil(cx);
						var ii_max2 = Math.ceil(lastX);
						var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this3;
					} else {
						var ii_min3 = Math.floor(cx);
						var ii_max3 = Math.ceil(nextX);
						var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this4;
					}
					var yIter3;
					if(cy > lastY) {
						if(cy > nextY) {
							var ii_min4 = lastY > nextY ? Math.floor(nextY) : Math.floor(lastY);
							var ii_max4 = Math.ceil(cy);
							var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this5;
						} else {
							var ii_min5 = Math.floor(lastY);
							var ii_max5 = Math.ceil(nextY);
							var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this6;
						}
					} else if(lastY > nextY) {
						var ii_min6 = cy > nextY ? Math.floor(nextY) : Math.ceil(cy);
						var ii_max6 = Math.ceil(lastY);
						var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this7;
					} else {
						var ii_min7 = Math.floor(cy);
						var ii_max7 = Math.ceil(nextY);
						var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this8;
					}
					var undoImage = null;
					var found = false;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var px = _g_min++;
						var pcx = px - nextX;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var py = _g_min1++;
							var pcy = py - nextY;
							var dot31 = pcx * bcx + pcy * bcy;
							var dot32 = pcx * acx + pcy * acy;
							var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
							var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
							var ratioC = 1.0 - ratioB - ratioA;
							if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
								var i1 = aA * (softC1 * ratioB) | 0;
								if(i1 > 255) {
									i1 = 255;
								}
								if(i1 < 0) {
									i1 = 0;
								}
								var this9 = i1;
								var a = this9;
								var i2 = rA | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this10 = i2;
								var r = this10;
								var i3 = gA | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this11 = i3;
								var g = this11;
								var i4 = bA | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this12 = i4;
								var b = this12;
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								if(temp.transparent && a < 254) {
									var this13 = temp.image[location];
									var this14 = this13;
									var old = pixelimageXY_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
									var rhs = a << 24 | r << 16 | g << 8 | b;
									var this15 = old >> 24 & 255;
									var a1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = old >> 16 & 255;
									var r1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = old >> 8 & 255;
									var g1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = old & 255;
									var b1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = rhs >> 24 & 255;
									var a2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = rhs >> 16 & 255;
									var r2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = rhs >> 8 & 255;
									var g2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = rhs & 255;
									var b2 = this22 == 0 ? 0. : this22 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									temp.image[location] = temp.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					var v_yIter3;
					var v_xIter3;
					var v_ty;
					var v_tx;
					var v_t0;
					var v_sy;
					var v_sx;
					var v_s0;
					var v_A;
					var ax = cx;
					var ay = cy;
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var preCalculated = true;
					if(preCalculated == null) {
						preCalculated = true;
					}
					var v_undoImage = null;
					var adjustWinding = ax * by - bx * ay + (bx * cy1 - cx1 * by) + (cx1 * ay - ax * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var v_ax = ax;
					var v_ay = ay;
					var v_bx = bx;
					var v_by = by;
					var v_cx = cx1;
					var v_cy = cy1;
					var v_preCalculated = preCalculated;
					if(preCalculated) {
						v_s0 = v_ay * v_cx - v_ax * v_cy;
						v_sx = v_cy - v_ay;
						v_sy = v_ax - v_cx;
						v_t0 = v_ax * v_by - v_ay * v_bx;
						v_tx = v_ay - v_by;
						v_ty = v_bx - v_ax;
						v_A = -v_by * v_cx + v_ay * (-v_bx + v_cx) + v_ax * (v_by - v_cy) + v_bx * v_cy;
						var a5 = v_ax;
						var b4 = v_bx;
						var c = v_cx;
						if(a5 > b4) {
							if(a5 > c) {
								var ii_min8 = b4 > c ? Math.floor(c) : Math.floor(b4);
								var ii_max8 = Math.ceil(a5);
								var this23 = new pixelimageXY_iter_IntIterStart(ii_min8,ii_max8);
								v_xIter3 = this23;
							} else {
								var ii_min9 = Math.floor(b4);
								var ii_max9 = Math.ceil(c);
								var this24 = new pixelimageXY_iter_IntIterStart(ii_min9,ii_max9);
								v_xIter3 = this24;
							}
						} else if(b4 > c) {
							var ii_min10 = a5 > c ? Math.floor(c) : Math.ceil(a5);
							var ii_max10 = Math.ceil(b4);
							var this25 = new pixelimageXY_iter_IntIterStart(ii_min10,ii_max10);
							v_xIter3 = this25;
						} else {
							var ii_min11 = Math.floor(a5);
							var ii_max11 = Math.ceil(c);
							var this26 = new pixelimageXY_iter_IntIterStart(ii_min11,ii_max11);
							v_xIter3 = this26;
						}
						var a6 = v_ay;
						var b5 = v_by;
						var c1 = v_cy;
						if(a6 > b5) {
							if(a6 > c1) {
								var ii_min12 = b5 > c1 ? Math.floor(c1) : Math.floor(b5);
								var ii_max12 = Math.ceil(a6);
								var this27 = new pixelimageXY_iter_IntIterStart(ii_min12,ii_max12);
								v_yIter3 = this27;
							} else {
								var ii_min13 = Math.floor(b5);
								var ii_max13 = Math.ceil(c1);
								var this28 = new pixelimageXY_iter_IntIterStart(ii_min13,ii_max13);
								v_yIter3 = this28;
							}
						} else if(b5 > c1) {
							var ii_min14 = a6 > c1 ? Math.floor(c1) : Math.ceil(a6);
							var ii_max14 = Math.ceil(b5);
							var this29 = new pixelimageXY_iter_IntIterStart(ii_min14,ii_max14);
							v_yIter3 = this29;
						} else {
							var ii_min15 = Math.floor(a6);
							var ii_max15 = Math.ceil(c1);
							var this30 = new pixelimageXY_iter_IntIterStart(ii_min15,ii_max15);
							v_yIter3 = this30;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			} else {
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var nextX = cx + rW * Math.cos(i * theta + omega + 0.01);
					var nextY = cy + rH * Math.sin(i * theta + omega + 0.01);
					var softC1 = softC;
					if(softC1 == null) {
						softC1 = 10;
					}
					var aA = color >> 24 & 255;
					var rA = color >> 16 & 255;
					var gA = color >> 8 & 255;
					var bA = color & 255;
					var bcx = lastX - nextX;
					var bcy = lastY - nextY;
					var acx = cx - nextX;
					var acy = cy - nextY;
					var dot11 = bcx * bcx + bcy * bcy;
					var dot12 = bcx * acx + bcy * acy;
					var dot22 = acx * acx + acy * acy;
					var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
					var xIter3;
					if(cx > lastX) {
						if(cx > nextX) {
							var ii_min = lastX > nextX ? Math.floor(nextX) : Math.floor(lastX);
							var ii_max = Math.ceil(cx);
							var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this1;
						} else {
							var ii_min1 = Math.floor(lastX);
							var ii_max1 = Math.ceil(nextX);
							var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this2;
						}
					} else if(lastX > nextX) {
						var ii_min2 = cx > nextX ? Math.floor(nextX) : Math.ceil(cx);
						var ii_max2 = Math.ceil(lastX);
						var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this3;
					} else {
						var ii_min3 = Math.floor(cx);
						var ii_max3 = Math.ceil(nextX);
						var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this4;
					}
					var yIter3;
					if(cy > lastY) {
						if(cy > nextY) {
							var ii_min4 = lastY > nextY ? Math.floor(nextY) : Math.floor(lastY);
							var ii_max4 = Math.ceil(cy);
							var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this5;
						} else {
							var ii_min5 = Math.floor(lastY);
							var ii_max5 = Math.ceil(nextY);
							var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this6;
						}
					} else if(lastY > nextY) {
						var ii_min6 = cy > nextY ? Math.floor(nextY) : Math.ceil(cy);
						var ii_max6 = Math.ceil(lastY);
						var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this7;
					} else {
						var ii_min7 = Math.floor(cy);
						var ii_max7 = Math.ceil(nextY);
						var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this8;
					}
					var undoImage = null;
					var found = false;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var px = _g_min++;
						var pcx = px - nextX;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var py = _g_min1++;
							var pcy = py - nextY;
							var dot31 = pcx * bcx + pcy * bcy;
							var dot32 = pcx * acx + pcy * acy;
							var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
							var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
							var ratioC = 1.0 - ratioB - ratioA;
							if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
								var i1 = aA * (softC1 * ratioB) | 0;
								if(i1 > 255) {
									i1 = 255;
								}
								if(i1 < 0) {
									i1 = 0;
								}
								var this9 = i1;
								var a = this9;
								var i2 = rA | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this10 = i2;
								var r = this10;
								var i3 = gA | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this11 = i3;
								var g = this11;
								var i4 = bA | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this12 = i4;
								var b = this12;
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								if(temp.transparent && a < 254) {
									var this13 = temp.image[location];
									var this14 = this13;
									var old = pixelimageXY_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
									var rhs = a << 24 | r << 16 | g << 8 | b;
									var this15 = old >> 24 & 255;
									var a1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = old >> 16 & 255;
									var r1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = old >> 8 & 255;
									var g1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = old & 255;
									var b1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = rhs >> 24 & 255;
									var a2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = rhs >> 16 & 255;
									var r2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = rhs >> 8 & 255;
									var g2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = rhs & 255;
									var b2 = this22 == 0 ? 0. : this22 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									temp.image[location] = temp.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					var v_yIter3;
					var v_xIter3;
					var v_ty;
					var v_tx;
					var v_t0;
					var v_sy;
					var v_sx;
					var v_s0;
					var v_A;
					var ax = cx;
					var ay = cy;
					var bx = lastX;
					var by = lastY;
					var cx1 = nextX;
					var cy1 = nextY;
					var preCalculated = true;
					if(preCalculated == null) {
						preCalculated = true;
					}
					var v_undoImage = null;
					var adjustWinding = ax * by - bx * ay + (bx * cy1 - cx1 * by) + (cx1 * ay - ax * cy1) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx1;
						by = cy1;
						cx1 = bx_;
						cy1 = by_;
					}
					var v_ax = ax;
					var v_ay = ay;
					var v_bx = bx;
					var v_by = by;
					var v_cx = cx1;
					var v_cy = cy1;
					var v_preCalculated = preCalculated;
					if(preCalculated) {
						v_s0 = v_ay * v_cx - v_ax * v_cy;
						v_sx = v_cy - v_ay;
						v_sy = v_ax - v_cx;
						v_t0 = v_ax * v_by - v_ay * v_bx;
						v_tx = v_ay - v_by;
						v_ty = v_bx - v_ax;
						v_A = -v_by * v_cx + v_ay * (-v_bx + v_cx) + v_ax * (v_by - v_cy) + v_bx * v_cy;
						var a5 = v_ax;
						var b4 = v_bx;
						var c = v_cx;
						if(a5 > b4) {
							if(a5 > c) {
								var ii_min8 = b4 > c ? Math.floor(c) : Math.floor(b4);
								var ii_max8 = Math.ceil(a5);
								var this23 = new pixelimageXY_iter_IntIterStart(ii_min8,ii_max8);
								v_xIter3 = this23;
							} else {
								var ii_min9 = Math.floor(b4);
								var ii_max9 = Math.ceil(c);
								var this24 = new pixelimageXY_iter_IntIterStart(ii_min9,ii_max9);
								v_xIter3 = this24;
							}
						} else if(b4 > c) {
							var ii_min10 = a5 > c ? Math.floor(c) : Math.ceil(a5);
							var ii_max10 = Math.ceil(b4);
							var this25 = new pixelimageXY_iter_IntIterStart(ii_min10,ii_max10);
							v_xIter3 = this25;
						} else {
							var ii_min11 = Math.floor(a5);
							var ii_max11 = Math.ceil(c);
							var this26 = new pixelimageXY_iter_IntIterStart(ii_min11,ii_max11);
							v_xIter3 = this26;
						}
						var a6 = v_ay;
						var b5 = v_by;
						var c1 = v_cy;
						if(a6 > b5) {
							if(a6 > c1) {
								var ii_min12 = b5 > c1 ? Math.floor(c1) : Math.floor(b5);
								var ii_max12 = Math.ceil(a6);
								var this27 = new pixelimageXY_iter_IntIterStart(ii_min12,ii_max12);
								v_yIter3 = this27;
							} else {
								var ii_min13 = Math.floor(b5);
								var ii_max13 = Math.ceil(c1);
								var this28 = new pixelimageXY_iter_IntIterStart(ii_min13,ii_max13);
								v_yIter3 = this28;
							}
						} else if(b5 > c1) {
							var ii_min14 = a6 > c1 ? Math.floor(c1) : Math.ceil(a6);
							var ii_max14 = Math.ceil(b5);
							var this29 = new pixelimageXY_iter_IntIterStart(ii_min14,ii_max14);
							v_yIter3 = this29;
						} else {
							var ii_min15 = Math.floor(a6);
							var ii_max15 = Math.ceil(c1);
							var this30 = new pixelimageXY_iter_IntIterStart(ii_min15,ii_max15);
							v_yIter3 = this30;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			}
			var color = this.fill;
			var phi1 = phi;
			var softC = this.edgeSoft;
			if(softC == null) {
				softC = 10;
			}
			if(phi1 == null) {
				phi1 = 0;
			}
			var rSmall = innerRw > innerRh ? innerRh : innerRw;
			var targetE = 1.05;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var phi = phi1;
			var sides = noSides;
			var softC1 = softC;
			if(softC1 == null) {
				softC1 = 10.;
			}
			if(sides == null) {
				sides = 36;
			}
			if(phi == null) {
				phi = 0.;
			}
			var phi1 = phi;
			var sides1 = sides;
			var softC = softC1;
			var cornerUp = true;
			if(cornerUp == null) {
				cornerUp = true;
			}
			if(softC == null) {
				softC = 10;
			}
			if(sides1 == null) {
				sides1 = 36;
			}
			if(phi1 == null) {
				phi1 = 0.;
			}
			var theta = 2 * Math.PI / sides1;
			var omega;
			if(cornerUp) {
				omega = 0.;
			} else if((sides1 / 2 | 0) == sides1 / 2) {
				omega = Math.PI / sides1;
			} else {
				var v = sides1 / 2 - 0.5;
				omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
			}
			var lastX = 0.;
			var lastY = 0.;
			if(phi1 != 0) {
				lastX = innerRw * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - innerRh * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + innerCx;
				lastY = innerRw * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + innerRh * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + innerCy;
			} else {
				lastX = innerCx + innerRw * Math.cos(sides1 * theta + omega);
				lastY = innerCy + innerRh * Math.sin(sides1 * theta + omega);
			}
			if(phi1 != 0) {
				var cphi = Math.cos(phi1);
				var sphi = Math.sin(phi1);
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var stheta = Math.sin(i * theta + omega + 0.01);
					var ctheta = Math.cos(i * theta + omega + 0.01);
					var nextX = innerRw * ctheta * cphi - innerRh * stheta * sphi + innerCx;
					var nextY = innerRw * ctheta * sphi + innerRh * stheta * cphi + innerCy;
					var softC1 = softC;
					if(softC1 == null) {
						softC1 = 10;
					}
					var aA = color >> 24 & 255;
					var rA = color >> 16 & 255;
					var gA = color >> 8 & 255;
					var bA = color & 255;
					var bcx = lastX - nextX;
					var bcy = lastY - nextY;
					var acx = innerCx - nextX;
					var acy = innerCy - nextY;
					var dot11 = bcx * bcx + bcy * bcy;
					var dot12 = bcx * acx + bcy * acy;
					var dot22 = acx * acx + acy * acy;
					var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
					var xIter3;
					if(innerCx > lastX) {
						if(innerCx > nextX) {
							var ii_min = lastX > nextX ? Math.floor(nextX) : Math.floor(lastX);
							var ii_max = Math.ceil(innerCx);
							var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this1;
						} else {
							var ii_min1 = Math.floor(lastX);
							var ii_max1 = Math.ceil(nextX);
							var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this2;
						}
					} else if(lastX > nextX) {
						var ii_min2 = innerCx > nextX ? Math.floor(nextX) : Math.ceil(innerCx);
						var ii_max2 = Math.ceil(lastX);
						var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this3;
					} else {
						var ii_min3 = Math.floor(innerCx);
						var ii_max3 = Math.ceil(nextX);
						var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this4;
					}
					var yIter3;
					if(innerCy > lastY) {
						if(innerCy > nextY) {
							var ii_min4 = lastY > nextY ? Math.floor(nextY) : Math.floor(lastY);
							var ii_max4 = Math.ceil(innerCy);
							var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this5;
						} else {
							var ii_min5 = Math.floor(lastY);
							var ii_max5 = Math.ceil(nextY);
							var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this6;
						}
					} else if(lastY > nextY) {
						var ii_min6 = innerCy > nextY ? Math.floor(nextY) : Math.ceil(innerCy);
						var ii_max6 = Math.ceil(lastY);
						var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this7;
					} else {
						var ii_min7 = Math.floor(innerCy);
						var ii_max7 = Math.ceil(nextY);
						var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this8;
					}
					var undoImage = null;
					var found = false;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var px = _g_min++;
						var pcx = px - nextX;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var py = _g_min1++;
							var pcy = py - nextY;
							var dot31 = pcx * bcx + pcy * bcy;
							var dot32 = pcx * acx + pcy * acy;
							var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
							var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
							var ratioC = 1.0 - ratioB - ratioA;
							if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
								var i1 = aA * (softC1 * ratioB) | 0;
								if(i1 > 255) {
									i1 = 255;
								}
								if(i1 < 0) {
									i1 = 0;
								}
								var this9 = i1;
								var a = this9;
								var i2 = rA | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this10 = i2;
								var r = this10;
								var i3 = gA | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this11 = i3;
								var g = this11;
								var i4 = bA | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this12 = i4;
								var b = this12;
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								if(temp.transparent && a < 254) {
									var this13 = temp.image[location];
									var this14 = this13;
									var old = pixelimageXY_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
									var rhs = a << 24 | r << 16 | g << 8 | b;
									var this15 = old >> 24 & 255;
									var a1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = old >> 16 & 255;
									var r1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = old >> 8 & 255;
									var g1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = old & 255;
									var b1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = rhs >> 24 & 255;
									var a2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = rhs >> 16 & 255;
									var r2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = rhs >> 8 & 255;
									var g2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = rhs & 255;
									var b2 = this22 == 0 ? 0. : this22 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									temp.image[location] = temp.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					var v_yIter3;
					var v_xIter3;
					var v_ty;
					var v_tx;
					var v_t0;
					var v_sy;
					var v_sx;
					var v_s0;
					var v_A;
					var ax = innerCx;
					var ay = innerCy;
					var bx = lastX;
					var by = lastY;
					var cx = nextX;
					var cy = nextY;
					var preCalculated = true;
					if(preCalculated == null) {
						preCalculated = true;
					}
					var v_undoImage = null;
					var adjustWinding = ax * by - bx * ay + (bx * cy - cx * by) + (cx * ay - ax * cy) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx;
						by = cy;
						cx = bx_;
						cy = by_;
					}
					var v_ax = ax;
					var v_ay = ay;
					var v_bx = bx;
					var v_by = by;
					var v_cx = cx;
					var v_cy = cy;
					var v_preCalculated = preCalculated;
					if(preCalculated) {
						v_s0 = v_ay * v_cx - v_ax * v_cy;
						v_sx = v_cy - v_ay;
						v_sy = v_ax - v_cx;
						v_t0 = v_ax * v_by - v_ay * v_bx;
						v_tx = v_ay - v_by;
						v_ty = v_bx - v_ax;
						v_A = -v_by * v_cx + v_ay * (-v_bx + v_cx) + v_ax * (v_by - v_cy) + v_bx * v_cy;
						var a5 = v_ax;
						var b4 = v_bx;
						var c = v_cx;
						if(a5 > b4) {
							if(a5 > c) {
								var ii_min8 = b4 > c ? Math.floor(c) : Math.floor(b4);
								var ii_max8 = Math.ceil(a5);
								var this23 = new pixelimageXY_iter_IntIterStart(ii_min8,ii_max8);
								v_xIter3 = this23;
							} else {
								var ii_min9 = Math.floor(b4);
								var ii_max9 = Math.ceil(c);
								var this24 = new pixelimageXY_iter_IntIterStart(ii_min9,ii_max9);
								v_xIter3 = this24;
							}
						} else if(b4 > c) {
							var ii_min10 = a5 > c ? Math.floor(c) : Math.ceil(a5);
							var ii_max10 = Math.ceil(b4);
							var this25 = new pixelimageXY_iter_IntIterStart(ii_min10,ii_max10);
							v_xIter3 = this25;
						} else {
							var ii_min11 = Math.floor(a5);
							var ii_max11 = Math.ceil(c);
							var this26 = new pixelimageXY_iter_IntIterStart(ii_min11,ii_max11);
							v_xIter3 = this26;
						}
						var a6 = v_ay;
						var b5 = v_by;
						var c1 = v_cy;
						if(a6 > b5) {
							if(a6 > c1) {
								var ii_min12 = b5 > c1 ? Math.floor(c1) : Math.floor(b5);
								var ii_max12 = Math.ceil(a6);
								var this27 = new pixelimageXY_iter_IntIterStart(ii_min12,ii_max12);
								v_yIter3 = this27;
							} else {
								var ii_min13 = Math.floor(b5);
								var ii_max13 = Math.ceil(c1);
								var this28 = new pixelimageXY_iter_IntIterStart(ii_min13,ii_max13);
								v_yIter3 = this28;
							}
						} else if(b5 > c1) {
							var ii_min14 = a6 > c1 ? Math.floor(c1) : Math.ceil(a6);
							var ii_max14 = Math.ceil(b5);
							var this29 = new pixelimageXY_iter_IntIterStart(ii_min14,ii_max14);
							v_yIter3 = this29;
						} else {
							var ii_min15 = Math.floor(a6);
							var ii_max15 = Math.ceil(c1);
							var this30 = new pixelimageXY_iter_IntIterStart(ii_min15,ii_max15);
							v_yIter3 = this30;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			} else {
				var _g = 0;
				var _g1 = sides1 + 1;
				while(_g < _g1) {
					var i = _g++;
					var nextX = innerCx + innerRw * Math.cos(i * theta + omega + 0.01);
					var nextY = innerCy + innerRh * Math.sin(i * theta + omega + 0.01);
					var softC1 = softC;
					if(softC1 == null) {
						softC1 = 10;
					}
					var aA = color >> 24 & 255;
					var rA = color >> 16 & 255;
					var gA = color >> 8 & 255;
					var bA = color & 255;
					var bcx = lastX - nextX;
					var bcy = lastY - nextY;
					var acx = innerCx - nextX;
					var acy = innerCy - nextY;
					var dot11 = bcx * bcx + bcy * bcy;
					var dot12 = bcx * acx + bcy * acy;
					var dot22 = acx * acx + acy * acy;
					var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
					var xIter3;
					if(innerCx > lastX) {
						if(innerCx > nextX) {
							var ii_min = lastX > nextX ? Math.floor(nextX) : Math.floor(lastX);
							var ii_max = Math.ceil(innerCx);
							var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
							xIter3 = this1;
						} else {
							var ii_min1 = Math.floor(lastX);
							var ii_max1 = Math.ceil(nextX);
							var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
							xIter3 = this2;
						}
					} else if(lastX > nextX) {
						var ii_min2 = innerCx > nextX ? Math.floor(nextX) : Math.ceil(innerCx);
						var ii_max2 = Math.ceil(lastX);
						var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
						xIter3 = this3;
					} else {
						var ii_min3 = Math.floor(innerCx);
						var ii_max3 = Math.ceil(nextX);
						var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
						xIter3 = this4;
					}
					var yIter3;
					if(innerCy > lastY) {
						if(innerCy > nextY) {
							var ii_min4 = lastY > nextY ? Math.floor(nextY) : Math.floor(lastY);
							var ii_max4 = Math.ceil(innerCy);
							var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
							yIter3 = this5;
						} else {
							var ii_min5 = Math.floor(lastY);
							var ii_max5 = Math.ceil(nextY);
							var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
							yIter3 = this6;
						}
					} else if(lastY > nextY) {
						var ii_min6 = innerCy > nextY ? Math.floor(nextY) : Math.ceil(innerCy);
						var ii_max6 = Math.ceil(lastY);
						var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
						yIter3 = this7;
					} else {
						var ii_min7 = Math.floor(innerCy);
						var ii_max7 = Math.ceil(nextY);
						var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
						yIter3 = this8;
					}
					var undoImage = null;
					var found = false;
					var _g_min = xIter3.start;
					var _g_max = xIter3.max;
					while(_g_min < _g_max) {
						var px = _g_min++;
						var pcx = px - nextX;
						found = false;
						var _g_min1 = yIter3.start;
						var _g_max1 = yIter3.max;
						while(_g_min1 < _g_max1) {
							var py = _g_min1++;
							var pcy = py - nextY;
							var dot31 = pcx * bcx + pcy * bcy;
							var dot32 = pcx * acx + pcy * acy;
							var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
							var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
							var ratioC = 1.0 - ratioB - ratioA;
							if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
								var i1 = aA * (softC1 * ratioB) | 0;
								if(i1 > 255) {
									i1 = 255;
								}
								if(i1 < 0) {
									i1 = 0;
								}
								var this9 = i1;
								var a = this9;
								var i2 = rA | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this10 = i2;
								var r = this10;
								var i3 = gA | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this11 = i3;
								var g = this11;
								var i4 = bA | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this12 = i4;
								var b = this12;
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								if(temp.transparent && a < 254) {
									var this13 = temp.image[location];
									var this14 = this13;
									var old = pixelimageXY_Endian_isLittleEndian ? (this14 >> 24 & 255) << 24 | (this14 & 255) << 16 | (this14 >> 8 & 255) << 8 | this14 >> 16 & 255 : this14;
									var rhs = a << 24 | r << 16 | g << 8 | b;
									var this15 = old >> 24 & 255;
									var a1 = this15 == 0 ? 0. : this15 / 255;
									var this16 = old >> 16 & 255;
									var r1 = this16 == 0 ? 0. : this16 / 255;
									var this17 = old >> 8 & 255;
									var g1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = old & 255;
									var b1 = this18 == 0 ? 0. : this18 / 255;
									var this19 = rhs >> 24 & 255;
									var a2 = this19 == 0 ? 0. : this19 / 255;
									var this20 = rhs >> 16 & 255;
									var r2 = this20 == 0 ? 0. : this20 / 255;
									var this21 = rhs >> 8 & 255;
									var g2 = this21 == 0 ? 0. : this21 / 255;
									var this22 = rhs & 255;
									var b2 = this22 == 0 ? 0. : this22 / 255;
									var a3 = a1 * (1 - a2);
									var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
									var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
									var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
									var a4 = 255 * (a3 + a2) | 0;
									var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
									temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									temp.image[location] = temp.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
								}
								found = true;
							} else if(found) {
								break;
							}
						}
					}
					var v_yIter3;
					var v_xIter3;
					var v_ty;
					var v_tx;
					var v_t0;
					var v_sy;
					var v_sx;
					var v_s0;
					var v_A;
					var ax = innerCx;
					var ay = innerCy;
					var bx = lastX;
					var by = lastY;
					var cx = nextX;
					var cy = nextY;
					var preCalculated = true;
					if(preCalculated == null) {
						preCalculated = true;
					}
					var v_undoImage = null;
					var adjustWinding = ax * by - bx * ay + (bx * cy - cx * by) + (cx * ay - ax * cy) > 0;
					if(!adjustWinding) {
						var bx_ = bx;
						var by_ = by;
						bx = cx;
						by = cy;
						cx = bx_;
						cy = by_;
					}
					var v_ax = ax;
					var v_ay = ay;
					var v_bx = bx;
					var v_by = by;
					var v_cx = cx;
					var v_cy = cy;
					var v_preCalculated = preCalculated;
					if(preCalculated) {
						v_s0 = v_ay * v_cx - v_ax * v_cy;
						v_sx = v_cy - v_ay;
						v_sy = v_ax - v_cx;
						v_t0 = v_ax * v_by - v_ay * v_bx;
						v_tx = v_ay - v_by;
						v_ty = v_bx - v_ax;
						v_A = -v_by * v_cx + v_ay * (-v_bx + v_cx) + v_ax * (v_by - v_cy) + v_bx * v_cy;
						var a5 = v_ax;
						var b4 = v_bx;
						var c = v_cx;
						if(a5 > b4) {
							if(a5 > c) {
								var ii_min8 = b4 > c ? Math.floor(c) : Math.floor(b4);
								var ii_max8 = Math.ceil(a5);
								var this23 = new pixelimageXY_iter_IntIterStart(ii_min8,ii_max8);
								v_xIter3 = this23;
							} else {
								var ii_min9 = Math.floor(b4);
								var ii_max9 = Math.ceil(c);
								var this24 = new pixelimageXY_iter_IntIterStart(ii_min9,ii_max9);
								v_xIter3 = this24;
							}
						} else if(b4 > c) {
							var ii_min10 = a5 > c ? Math.floor(c) : Math.ceil(a5);
							var ii_max10 = Math.ceil(b4);
							var this25 = new pixelimageXY_iter_IntIterStart(ii_min10,ii_max10);
							v_xIter3 = this25;
						} else {
							var ii_min11 = Math.floor(a5);
							var ii_max11 = Math.ceil(c);
							var this26 = new pixelimageXY_iter_IntIterStart(ii_min11,ii_max11);
							v_xIter3 = this26;
						}
						var a6 = v_ay;
						var b5 = v_by;
						var c1 = v_cy;
						if(a6 > b5) {
							if(a6 > c1) {
								var ii_min12 = b5 > c1 ? Math.floor(c1) : Math.floor(b5);
								var ii_max12 = Math.ceil(a6);
								var this27 = new pixelimageXY_iter_IntIterStart(ii_min12,ii_max12);
								v_yIter3 = this27;
							} else {
								var ii_min13 = Math.floor(b5);
								var ii_max13 = Math.ceil(c1);
								var this28 = new pixelimageXY_iter_IntIterStart(ii_min13,ii_max13);
								v_yIter3 = this28;
							}
						} else if(b5 > c1) {
							var ii_min14 = a6 > c1 ? Math.floor(c1) : Math.ceil(a6);
							var ii_max14 = Math.ceil(b5);
							var this29 = new pixelimageXY_iter_IntIterStart(ii_min14,ii_max14);
							v_yIter3 = this29;
						} else {
							var ii_min15 = Math.floor(a6);
							var ii_max15 = Math.ceil(c1);
							var this30 = new pixelimageXY_iter_IntIterStart(ii_min15,ii_max15);
							v_yIter3 = this30;
						}
					}
					lastX = nextX;
					lastY = nextY;
				}
			}
		}
		var x = this.left + this.offX | 0;
		var y = this.top + this.offY | 0;
		var _g = 0;
		var _g1 = temp.height;
		while(_g < _g1) {
			var dy = _g++;
			var _g2 = 0;
			var _g3 = temp.width;
			while(_g2 < _g3) {
				var dx = _g2++;
				var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
				var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(temp.useMask && temp.mask != null) {
					var this1 = temp.mask;
					var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
					var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					var maskPixel = this2;
					var this3 = col;
					var this4 = this3;
					if(maskPixel == 0) {
						var this5 = this4;
						col = this5;
					} else {
						var this6 = maskPixel >> 24 & 255;
						var m0 = this6 == 0 ? 0. : this6 / 255;
						var this7 = maskPixel >> 16 & 255;
						var m1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = maskPixel >> 8 & 255;
						var m2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = maskPixel & 255;
						var m3 = this9 == 0 ? 0. : this9 / 255;
						var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
						var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
						var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
						var ch3 = (1. - m3) * (this4 & 255) | 0;
						col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
					}
				}
				if(col != 0) {
					var x1 = x + dx;
					var y1 = y + dy;
					var this10 = col;
					var c2 = this10;
					if((c2 >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0;
						var this11 = pixelShape.image[location];
						var this12 = this11;
						var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
						var this14 = this13 >> 24 & 255;
						var a1 = this14 == 0 ? 0. : this14 / 255;
						var this15 = this13 >> 16 & 255;
						var r1 = this15 == 0 ? 0. : this15 / 255;
						var this16 = this13 >> 8 & 255;
						var g1 = this16 == 0 ? 0. : this16 / 255;
						var this17 = this13 & 255;
						var b1 = this17 == 0 ? 0. : this17 / 255;
						var this18 = col >> 24 & 255;
						var a2 = this18 == 0 ? 0. : this18 / 255;
						var this19 = col >> 16 & 255;
						var r2 = this19 == 0 ? 0. : this19 / 255;
						var this20 = col >> 8 & 255;
						var g2 = this20 == 0 ? 0. : this20 / 255;
						var this21 = col & 255;
						var b2 = this21 == 0 ? 0. : this21 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					}
				}
			}
		}
		temp = null;
		return pixelShape;
	}
	,__class__: pixelimageXY_triangleGML_EllipseForm
});
var triangleGML_shape_contour_LineGridShape_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,left,top,width,height,delta,deltaH) {
	if(deltaH == null) {
		deltaH = 0.;
	}
	if(delta == null) {
		delta = 1.;
	}
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = -1048576;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_BasicShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.delta = delta;
	this.deltaH = deltaH;
};
triangleGML_shape_contour_LineGridShape_$.__name__ = "triangleGML.shape.contour.LineGridShape_";
triangleGML_shape_contour_LineGridShape_$.__super__ = triangleGML_BasicShape;
triangleGML_shape_contour_LineGridShape_$.prototype = $extend(triangleGML_BasicShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "delta":
			this.delta = parseFloat(value);
			break;
		case "deltaH":
			this.deltaH = parseFloat(value);
			break;
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			triangleGML_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: triangleGML_shape_contour_LineGridShape_$
});
var pixelimageXY_triangleGML_LineGridShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,left,top,width,height,delta,deltaH) {
	triangleGML_shape_contour_LineGridShape_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,left,top,width,height,delta,deltaH);
};
pixelimageXY_triangleGML_LineGridShape.__name__ = "pixelimageXY.triangleGML.LineGridShape";
pixelimageXY_triangleGML_LineGridShape.__super__ = triangleGML_shape_contour_LineGridShape_$;
pixelimageXY_triangleGML_LineGridShape.prototype = $extend(triangleGML_shape_contour_LineGridShape_$.prototype,{
	render: function(pixelShape) {
		if(this.rotation != 0. || this.skewX != 0. || this.skewY != 0. || this.scaleX != 1. || this.scaleY != 1.) {
			var w = Math.ceil(this.width);
			var h = Math.ceil(this.height);
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			var this1 = this2;
			var temp = this1;
			temp.transparent = false;
			if(this.deltaH != 0.) {
				var w = this.width;
				var h = this.height;
				var deltaW = this.delta;
				var deltaH = this.deltaH;
				var thick = this.strokeWidth;
				var color = this.strokeColor;
				var h_ = Math.floor(h / deltaH) * deltaH;
				var w_ = Math.floor(w / deltaW) * deltaW;
				var _g = 0;
				var _g1 = Math.floor(w / deltaW) + 1;
				while(_g < _g1) {
					var i = _g++;
					var x = i * deltaW - thick / 2;
					var p = x | 0;
					var xx = p;
					var q = 0;
					var maxX = x + thick | 0;
					var maxY = h_ | 0;
					while(true) {
						var x1 = p++;
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && temp.transparent) {
							var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : q * temp.width + x1 | 0;
							var this2 = temp.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : q * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						if(p > maxX) {
							p = xx;
							++q;
						}
						if(q > maxY) {
							break;
						}
					}
				}
				var _g = 0;
				var _g1 = Math.floor(h / deltaH) + 1;
				while(_g < _g1) {
					var i = _g++;
					var y = i * deltaH - thick / 2;
					var p = 0;
					var xx = p;
					var q = y | 0;
					var maxX = w_ | 0;
					var maxY = y + thick | 0;
					while(true) {
						var x = p++;
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && temp.transparent) {
							var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
							var this2 = temp.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						if(p > maxX) {
							p = xx;
							++q;
						}
						if(q > maxY) {
							break;
						}
					}
				}
			} else {
				var w = this.width;
				var h = this.height;
				var delta = this.delta;
				var thick = this.strokeWidth;
				var color = this.strokeColor;
				var h_ = Math.floor(h / delta) * delta;
				var w_ = Math.floor(w / delta) * delta;
				var _g = 0;
				var _g1 = Math.floor(w / delta) + 1;
				while(_g < _g1) {
					var i = _g++;
					var x = i * delta - thick / 2;
					var p = x | 0;
					var xx = p;
					var q = 0;
					var maxX = x + thick | 0;
					var maxY = h_ | 0;
					while(true) {
						var x1 = p++;
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && temp.transparent) {
							var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : q * temp.width + x1 | 0;
							var this2 = temp.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : q * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						if(p > maxX) {
							p = xx;
							++q;
						}
						if(q > maxY) {
							break;
						}
					}
				}
				var _g = 0;
				var _g1 = Math.floor(h / delta) + 1;
				while(_g < _g1) {
					var i = _g++;
					var y = i * delta - thick / 2;
					var p = 0;
					var xx = p;
					var q = y | 0;
					var maxX = w_ | 0;
					var maxY = y + thick | 0;
					while(true) {
						var x = p++;
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && temp.transparent) {
							var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
							var this2 = temp.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						if(p > maxX) {
							p = xx;
							++q;
						}
						if(q > maxY) {
							break;
						}
					}
				}
			}
			var win_x = 0;
			var win_y = 0;
			var win_width = temp.width;
			var win_height = temp.height;
			var w = Math.ceil(this.width);
			var h = Math.ceil(this.height);
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			var this1 = this2;
			var temp2 = this1;
			temp2.transparent = true;
			var wid = temp.width;
			var hi = temp.height;
			var theta = this.rotation;
			var centreX = this.transformCentreX;
			var centreY = this.transformCentreY;
			var skewX = this.skewX;
			var skewY = this.skewY;
			var scaleX = this.scaleX;
			var scaleY = this.scaleY;
			if(scaleY == null) {
				scaleY = 1.;
			}
			if(scaleX == null) {
				scaleX = 1.;
			}
			if(skewY == null) {
				skewY = 0.;
			}
			if(skewX == null) {
				skewX = 0.;
			}
			if(centreY == null) {
				centreY = 0.;
			}
			if(centreX == null) {
				centreX = 0.;
			}
			if(theta == null) {
				theta = 0.;
			}
			var ax = 0;
			var ay = 0;
			if(theta != 0.) {
				centreX = wid / 2 + centreX;
				centreY = hi / 2 + centreY;
				ax -= centreX;
				ay -= centreY;
			}
			var bx = ax + wid;
			var by = ay;
			var cx = bx;
			var cy = ay + hi;
			var dx = ax;
			var dy = cy;
			if(skewX != 0.) {
				ax += skewX;
				bx += skewX;
				cx -= skewX;
				dx -= skewX;
			}
			if(skewY != 0.) {
				ay -= skewY;
				dy -= skewY;
				by += skewY;
				cy += skewY;
			}
			if(scaleX != 1) {
				ax *= scaleX;
				bx *= scaleX;
				cx *= scaleX;
				dx *= scaleX;
			}
			if(scaleY != 1.) {
				ay *= scaleY;
				bx *= scaleY;
				cx *= scaleY;
				dx *= scaleY;
			}
			if(theta != 0) {
				var sin = Math.sin(theta);
				var cos = Math.cos(theta);
				var temp1 = ax;
				ax = temp1 * cos - ay * sin;
				ay = ay * cos + temp1 * sin;
				var temp1 = bx;
				bx = temp1 * cos - by * sin;
				by = by * cos + temp1 * sin;
				var temp1 = cx;
				cx = temp1 * cos - cy * sin;
				cy = cy * cos + temp1 * sin;
				var temp1 = dx;
				dx = temp1 * cos - dy * sin;
				dy = dy * cos + temp1 * sin;
				ax += centreX;
				ay += centreY;
				bx += centreX;
				by += centreY;
				cx += centreX;
				cy += centreY;
				dx += centreX;
				dy += centreY;
			}
			var hasHit = true;
			if(hasHit == null) {
				hasHit = true;
			}
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var au = 0.;
			var av = 0.;
			var bu = 1.;
			var bv = 0.;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var temp1 = au;
			au = bu;
			bu = temp1;
			temp1 = av;
			av = bv;
			bv = temp1;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var u = au * ratioA + bu * ratioB + 0. * ratioC;
						var v = av * ratioA + bv * ratioB + ratioC;
						var x = u * win_width + win_x | 0;
						var y = v * win_height + win_y | 0;
						var c = temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						var this1 = col;
						var c1 = this1;
						if((c1 >> 24 & 255) < 254 && temp2.transparent) {
							var location = temp2.useVirtualPos ? (py - temp2.virtualY) * temp2.width + px - temp2.virtualX | 0 : py * temp2.width + px | 0;
							var this2 = temp2.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = col >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = col >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = col >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = col & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp2.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp2.image[temp2.useVirtualPos ? (py - temp2.virtualY) * temp2.width + px - temp2.virtualX | 0 : py * temp2.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						}
					}
				}
			}
			if(hasHit == false) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx,by,dx,dy,true);
			}
			var au = 1.;
			var av = 0.;
			var bu = 1.;
			var bv = 1.;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var temp1 = au;
			au = bu;
			bu = temp1;
			temp1 = av;
			av = bv;
			bv = temp1;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var u = au * ratioA + bu * ratioB + 0. * ratioC;
						var v = av * ratioA + bv * ratioB + ratioC;
						var x = u * win_width + win_x | 0;
						var y = v * win_height + win_y | 0;
						var c = temp.image[temp.useVirtualPos ? (y - temp.virtualY) * temp.width + x - temp.virtualX | 0 : y * temp.width + x | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						var this1 = col;
						var c1 = this1;
						if((c1 >> 24 & 255) < 254 && temp2.transparent) {
							var location = temp2.useVirtualPos ? (py - temp2.virtualY) * temp2.width + px - temp2.virtualX | 0 : py * temp2.width + px | 0;
							var this2 = temp2.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = col >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = col >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = col >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = col & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							temp2.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							temp2.image[temp2.useVirtualPos ? (py - temp2.virtualY) * temp2.width + px - temp2.virtualX | 0 : py * temp2.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						}
					}
				}
			}
			if(hasHit == false) {
				var v = new pixelimageXY_algo_HitTri(bx,by,cx,cy,dx,dy,true);
			}
			if(hasHit1 == true) {
				var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
			}
			var x = this.left + this.offX | 0;
			var y = this.top + this.offY | 0;
			var _g = 0;
			var _g1 = temp2.height;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = 0;
				var _g3 = temp2.width;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = temp2.image[temp2.useVirtualPos ? (dy - temp2.virtualY) * temp2.width + dx - temp2.virtualX | 0 : dy * temp2.width + dx | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp2.useMask && temp2.mask != null) {
						var this1 = temp2.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x1 = x + dx;
						var y1 = y + dy;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && pixelShape.transparent) {
							var location = pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0;
							var this11 = pixelShape.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			temp = null;
			temp2 = null;
		} else if(this.deltaH != 0.) {
			var x = this.left + this.offX;
			var y = this.top + this.offY;
			var w = this.width;
			var h = this.height;
			var deltaW = this.delta;
			var deltaH = this.deltaH;
			var thick = this.strokeWidth;
			var color = this.strokeColor;
			var h_ = Math.floor(h / deltaH) * deltaH;
			var w_ = Math.floor(w / deltaW) * deltaW;
			var _g = 0;
			var _g1 = Math.floor(w / deltaW) + 1;
			while(_g < _g1) {
				var i = _g++;
				var x1 = x + i * deltaW - thick / 2;
				var p = x1 | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x1 + thick | 0;
				var maxY = y + h_ | 0;
				while(true) {
					var x2 = p++;
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x2 - pixelShape.virtualX | 0 : q * pixelShape.width + x2 | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x2 - pixelShape.virtualX | 0 : q * pixelShape.width + x2 | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
			}
			var _g = 0;
			var _g1 = Math.floor(h / deltaH) + 1;
			while(_g < _g1) {
				var i = _g++;
				var y1 = y + i * deltaH - thick / 2;
				var p = x | 0;
				var xx = p;
				var q = y1 | 0;
				var maxX = x + w_ | 0;
				var maxY = y1 + thick | 0;
				while(true) {
					var x1 = p++;
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : q * pixelShape.width + x1 | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : q * pixelShape.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
			}
		} else {
			var x = this.left + this.offX;
			var y = this.top + this.offY;
			var w = this.width;
			var h = this.height;
			var delta = this.delta;
			var thick = this.strokeWidth;
			var color = this.strokeColor;
			var h_ = Math.floor(h / delta) * delta;
			var w_ = Math.floor(w / delta) * delta;
			var _g = 0;
			var _g1 = Math.floor(w / delta) + 1;
			while(_g < _g1) {
				var i = _g++;
				var x1 = x + i * delta - thick / 2;
				var p = x1 | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x1 + thick | 0;
				var maxY = y + h_ | 0;
				while(true) {
					var x2 = p++;
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x2 - pixelShape.virtualX | 0 : q * pixelShape.width + x2 | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x2 - pixelShape.virtualX | 0 : q * pixelShape.width + x2 | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
			}
			var _g = 0;
			var _g1 = Math.floor(h / delta) + 1;
			while(_g < _g1) {
				var i = _g++;
				var y1 = y + i * delta - thick / 2;
				var p = x | 0;
				var xx = p;
				var q = y1 | 0;
				var maxX = x + w_ | 0;
				var maxY = y1 + thick | 0;
				while(true) {
					var x1 = p++;
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : q * pixelShape.width + x1 | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : q * pixelShape.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
			}
		}
		return pixelShape;
	}
	,__class__: pixelimageXY_triangleGML_LineGridShape
});
var triangleGML_shape_contour_LineShape_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,x1,y1,x2,y2,edgeSoft) {
	if(edgeSoft == null) {
		edgeSoft = 0.;
	}
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = -1048576;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_BasicShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.edgeSoft = edgeSoft;
};
triangleGML_shape_contour_LineShape_$.__name__ = "triangleGML.shape.contour.LineShape_";
triangleGML_shape_contour_LineShape_$.__super__ = triangleGML_BasicShape;
triangleGML_shape_contour_LineShape_$.prototype = $extend(triangleGML_BasicShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		default:
			triangleGML_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: triangleGML_shape_contour_LineShape_$
});
var pixelimageXY_triangleGML_LineShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,x1,y1,x2,y2,edgeSoft) {
	triangleGML_shape_contour_LineShape_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,x1,y1,x2,y2,edgeSoft);
};
pixelimageXY_triangleGML_LineShape.__name__ = "pixelimageXY.triangleGML.LineShape";
pixelimageXY_triangleGML_LineShape.__super__ = triangleGML_shape_contour_LineShape_$;
pixelimageXY_triangleGML_LineShape.prototype = $extend(triangleGML_shape_contour_LineShape_$.prototype,{
	setParameter: function(name,value) {
		if(name == "luxury") {
			this.luxury = StringTools.trim(value).toLowerCase() == "true";
			haxe_Log.trace("setting luxury " + value,{ fileName : "pixelimageXY/triangleGML/LineShape.hx", lineNumber : 13, className : "pixelimageXY.triangleGML.LineShape", methodName : "setParameter"});
		} else {
			triangleGML_shape_contour_LineShape_$.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelShape) {
		var px = this.x1 + this.offX;
		var qx = this.x2 + this.offX;
		var py = this.y1 + this.offY;
		var qy = this.y2 + this.offY;
		if(this.edgeSoft == 0.) {
			var color = this.strokeColor;
			var o = qy - py;
			var a = qx - px;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var hasHit = true;
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h;
			var cy = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = px + (ax * cos - ay * sin);
			ay = py + (ay * cos + ax * sin);
			ax = temp;
			temp = px + (bx * cos - by * sin);
			by = py + (by * cos + bx * sin);
			bx = temp;
			temp = px + (cx * cos - cy * sin);
			cy = py + (cy * cos + cx * sin);
			cx = temp;
			temp = px + (dx * cos - dy * sin);
			dy = py + (dy * cos + dx * sin);
			dx = temp;
			if(debugCorners) {
				var x = ax - 6.;
				var y = ay - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -65536;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = bx - 6.;
				var y = by - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -16711936;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 0;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = cx - 6.;
				var y = cy - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -16776961;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 0;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = dx - 6.;
				var y = dy - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -1048336;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 240;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 240;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
			}
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx1 > cx1) {
				var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by1 > cy1) {
				var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(pixelShape.useMask && pixelShape.mask != null) {
							var this1 = pixelShape.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && pixelShape.transparent) {
							var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
							var this2 = pixelShape.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var bx1 = cx;
			var by1 = cy;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = by * cx1 - bx * cy1;
			var sx = cy1 - by;
			var sy = bx - cx1;
			var t0 = bx * by1 - by * bx1;
			var tx = by - by1;
			var ty = bx1 - bx;
			var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(bx > bx1) {
				if(bx > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(bx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx1 > cx1) {
				var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
				var ii_max = Math.ceil(bx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(by > by1) {
				if(by > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(by);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by1 > cy1) {
				var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
				var ii_max = Math.ceil(by1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(pixelShape.useMask && pixelShape.mask != null) {
							var this1 = pixelShape.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && pixelShape.transparent) {
							var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
							var this2 = pixelShape.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pixelimageXY_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			if(hasHit1 == true) {
				var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
			}
		} else if(this.luxury) {
			var color = this.strokeColor;
			var soft = this.edgeSoft;
			if(soft == null) {
				soft = 40;
			}
			var o = qy - py;
			var a = qx - px;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var soft1 = soft;
			var softAB = true;
			var softBC = true;
			var softCD = true;
			var softDA = true;
			var hasHit = true;
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			if(softDA == null) {
				softDA = true;
			}
			if(softCD == null) {
				softCD = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft1 == null) {
				soft1 = 40.;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h;
			var cy = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = px + (ax * cos - ay * sin);
			ay = py + (ay * cos + ax * sin);
			ax = temp;
			temp = px + (bx * cos - by * sin);
			by = py + (by * cos + bx * sin);
			bx = temp;
			temp = px + (cx * cos - cy * sin);
			cy = py + (cy * cos + cx * sin);
			cx = temp;
			temp = px + (dx * cos - dy * sin);
			dy = py + (dy * cos + dx * sin);
			dx = temp;
			if(debugCorners) {
				var x = ax - 6.;
				var y = ay - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -65536;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = bx - 6.;
				var y = by - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -16711936;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 0;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = cx - 6.;
				var y = cy - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -16776961;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 0;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = dx - 6.;
				var y = dy - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -1048336;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 240;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 240;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
			}
			var soft = soft1;
			var softAB1 = softAB;
			var softBC1 = softBC;
			var softCD1 = softCD;
			var softDA1 = softDA;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softDA1 == null) {
				softDA1 = true;
			}
			if(softCD1 == null) {
				softCD1 = true;
			}
			if(softBC1 == null) {
				softBC1 = true;
			}
			if(softAB1 == null) {
				softAB1 = true;
			}
			if(soft == null) {
				soft = 40;
			}
			var soft3 = soft;
			var softAB = softAB1;
			var softBC = softBC1;
			var softCA = false;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - cx;
			var bcy = by - cy;
			var acx = ax - cx;
			var acy = ay - cy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > cx) {
					var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(cx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx > cx) {
				var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by) {
				if(ay > cy) {
					var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(cy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by > cy) {
				var ii_min = ay > cy ? Math.floor(cy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px1 = _g_min++;
				var pcx = px1 - cx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py1 = _g_min1++;
					var pcy = py1 - cy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this1 = i;
						r = this1;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this2 = i1;
						g = this2;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this3 = i2;
						b = this3;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this4 = i3;
							a = this4;
							var location = pixelShape.useVirtualPos ? (py1 - pixelShape.virtualY) * pixelShape.width + px1 - pixelShape.virtualX | 0 : py1 * pixelShape.width + px1 | 0;
							if(pixelShape.transparent && a < 254) {
								var this5 = pixelShape.image[location];
								var this6 = this5;
								var old = pixelimageXY_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this7 = old >> 24 & 255;
								var a1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = old >> 16 & 255;
								var r1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 8 & 255;
								var g1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old & 255;
								var b1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = rhs >> 24 & 255;
								var a2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 16 & 255;
								var r2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 8 & 255;
								var g2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs & 255;
								var b2 = this14 == 0 ? 0. : this14 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this15 = i4;
							a = this15;
							var location1 = pixelShape.useVirtualPos ? (py1 - pixelShape.virtualY) * pixelShape.width + px1 - pixelShape.virtualX | 0 : py1 * pixelShape.width + px1 | 0;
							if(pixelShape.transparent && a < 254) {
								var this16 = pixelShape.image[location1];
								var this17 = this16;
								var old1 = pixelimageXY_Endian_isLittleEndian ? (this17 >> 24 & 255) << 24 | (this17 & 255) << 16 | (this17 >> 8 & 255) << 8 | this17 >> 16 & 255 : this17;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this18 = old1 >> 24 & 255;
								var a11 = this18 == 0 ? 0. : this18 / 255;
								var this19 = old1 >> 16 & 255;
								var r11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 8 & 255;
								var g11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 & 255;
								var b11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = rhs1 >> 24 & 255;
								var a21 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 16 & 255;
								var r21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 8 & 255;
								var g21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 & 255;
								var b21 = this25 == 0 ? 0. : this25 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								pixelShape.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								pixelShape.image[location1] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx,by,cx,cy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft;
			var softAB = softCD1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - ax;
			var bcy = cy - ay;
			var acx = dx - ax;
			var acy = dy - ay;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(dx > cx) {
				if(dx > ax) {
					var ii_min = cx > ax ? Math.floor(ax) : Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(cx > ax) {
				var ii_min = dx > ax ? Math.floor(ax) : Math.ceil(dx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(dx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(dy > cy) {
				if(dy > ay) {
					var ii_min = cy > ay ? Math.floor(ay) : Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(cy > ay) {
				var ii_min = dy > ay ? Math.floor(ay) : Math.ceil(dy);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(dy);
				var ii_max = Math.ceil(ay);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px1 = _g_min++;
				var pcx = px1 - ax;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py1 = _g_min1++;
					var pcy = py1 - ay;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this1 = i;
						r = this1;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this2 = i1;
						g = this2;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this3 = i2;
						b = this3;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this4 = i3;
							a = this4;
							var location = pixelShape.useVirtualPos ? (py1 - pixelShape.virtualY) * pixelShape.width + px1 - pixelShape.virtualX | 0 : py1 * pixelShape.width + px1 | 0;
							if(pixelShape.transparent && a < 254) {
								var this5 = pixelShape.image[location];
								var this6 = this5;
								var old = pixelimageXY_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this7 = old >> 24 & 255;
								var a1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = old >> 16 & 255;
								var r1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 8 & 255;
								var g1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old & 255;
								var b1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = rhs >> 24 & 255;
								var a2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 16 & 255;
								var r2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 8 & 255;
								var g2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs & 255;
								var b2 = this14 == 0 ? 0. : this14 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this15 = i4;
							a = this15;
							var location1 = pixelShape.useVirtualPos ? (py1 - pixelShape.virtualY) * pixelShape.width + px1 - pixelShape.virtualX | 0 : py1 * pixelShape.width + px1 | 0;
							if(pixelShape.transparent && a < 254) {
								var this16 = pixelShape.image[location1];
								var this17 = this16;
								var old1 = pixelimageXY_Endian_isLittleEndian ? (this17 >> 24 & 255) << 24 | (this17 & 255) << 16 | (this17 >> 8 & 255) << 8 | this17 >> 16 & 255 : this17;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this18 = old1 >> 24 & 255;
								var a11 = this18 == 0 ? 0. : this18 / 255;
								var this19 = old1 >> 16 & 255;
								var r11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 8 & 255;
								var g11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 & 255;
								var b11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = rhs1 >> 24 & 255;
								var a21 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 16 & 255;
								var r21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 8 & 255;
								var g21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 & 255;
								var b21 = this25 == 0 ? 0. : this25 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								pixelShape.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								pixelShape.image[location1] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pixelimageXY_algo_HitTri(dx,dy,cx,cy,ax,ay,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft;
			var softAB = softAB1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px1 = _g_min++;
				var pcx = px1 - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py1 = _g_min1++;
					var pcy = py1 - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this1 = i;
						r = this1;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this2 = i1;
						g = this2;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this3 = i2;
						b = this3;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this4 = i3;
							a = this4;
							var location = pixelShape.useVirtualPos ? (py1 - pixelShape.virtualY) * pixelShape.width + px1 - pixelShape.virtualX | 0 : py1 * pixelShape.width + px1 | 0;
							if(pixelShape.transparent && a < 254) {
								var this5 = pixelShape.image[location];
								var this6 = this5;
								var old = pixelimageXY_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this7 = old >> 24 & 255;
								var a1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = old >> 16 & 255;
								var r1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 8 & 255;
								var g1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old & 255;
								var b1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = rhs >> 24 & 255;
								var a2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 16 & 255;
								var r2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 8 & 255;
								var g2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs & 255;
								var b2 = this14 == 0 ? 0. : this14 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this15 = i4;
							a = this15;
							var location1 = pixelShape.useVirtualPos ? (py1 - pixelShape.virtualY) * pixelShape.width + px1 - pixelShape.virtualX | 0 : py1 * pixelShape.width + px1 | 0;
							if(pixelShape.transparent && a < 254) {
								var this16 = pixelShape.image[location1];
								var this17 = this16;
								var old1 = pixelimageXY_Endian_isLittleEndian ? (this17 >> 24 & 255) << 24 | (this17 & 255) << 16 | (this17 >> 8 & 255) << 8 | this17 >> 16 & 255 : this17;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this18 = old1 >> 24 & 255;
								var a11 = this18 == 0 ? 0. : this18 / 255;
								var this19 = old1 >> 16 & 255;
								var r11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 8 & 255;
								var g11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 & 255;
								var b11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = rhs1 >> 24 & 255;
								var a21 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 16 & 255;
								var r21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 8 & 255;
								var g21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 & 255;
								var b21 = this25 == 0 ? 0. : this25 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								pixelShape.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								pixelShape.image[location1] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx,by,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft;
			var softAB = softBC1;
			var softBC = softCD1;
			var softCA = false;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px1 = _g_min++;
				var pcx = px1 - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py1 = _g_min1++;
					var pcy = py1 - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this1 = i;
						r = this1;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this2 = i1;
						g = this2;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this3 = i2;
						b = this3;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this4 = i3;
							a = this4;
							var location = pixelShape.useVirtualPos ? (py1 - pixelShape.virtualY) * pixelShape.width + px1 - pixelShape.virtualX | 0 : py1 * pixelShape.width + px1 | 0;
							if(pixelShape.transparent && a < 254) {
								var this5 = pixelShape.image[location];
								var this6 = this5;
								var old = pixelimageXY_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this7 = old >> 24 & 255;
								var a1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = old >> 16 & 255;
								var r1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 8 & 255;
								var g1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old & 255;
								var b1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = rhs >> 24 & 255;
								var a2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 16 & 255;
								var r2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 8 & 255;
								var g2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs & 255;
								var b2 = this14 == 0 ? 0. : this14 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this15 = i4;
							a = this15;
							var location1 = pixelShape.useVirtualPos ? (py1 - pixelShape.virtualY) * pixelShape.width + px1 - pixelShape.virtualX | 0 : py1 * pixelShape.width + px1 | 0;
							if(pixelShape.transparent && a < 254) {
								var this16 = pixelShape.image[location1];
								var this17 = this16;
								var old1 = pixelimageXY_Endian_isLittleEndian ? (this17 >> 24 & 255) << 24 | (this17 & 255) << 16 | (this17 >> 8 & 255) << 8 | this17 >> 16 & 255 : this17;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this18 = old1 >> 24 & 255;
								var a11 = this18 == 0 ? 0. : this18 / 255;
								var this19 = old1 >> 16 & 255;
								var r11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 8 & 255;
								var g11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 & 255;
								var b11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = rhs1 >> 24 & 255;
								var a21 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 16 & 255;
								var r21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 8 & 255;
								var g21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 & 255;
								var b21 = this25 == 0 ? 0. : this25 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								pixelShape.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								pixelShape.image[location1] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pixelimageXY_algo_HitTri(bx,by,cx,cy,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			if(hasHit1 == true) {
				var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
			}
		} else {
			haxe_Log.trace("luxury!!",{ fileName : "pixelimageXY/triangleGML/LineShape.hx", lineNumber : 30, className : "pixelimageXY.triangleGML.LineShape", methodName : "render"});
			var color = this.strokeColor;
			var soft = this.edgeSoft;
			if(soft == null) {
				soft = 40;
			}
			var o = qy - py;
			var a = qx - px;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var soft1 = soft;
			var softAB = true;
			var softBC = true;
			var softCD = true;
			var softDA = true;
			var hasHit = true;
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			if(hasHit == null) {
				hasHit = false;
			}
			if(softDA == null) {
				softDA = true;
			}
			if(softCD == null) {
				softCD = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft1 == null) {
				soft1 = 40.;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h;
			var cy = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = px + (ax * cos - ay * sin);
			ay = py + (ay * cos + ax * sin);
			ax = temp;
			temp = px + (bx * cos - by * sin);
			by = py + (by * cos + bx * sin);
			bx = temp;
			temp = px + (cx * cos - cy * sin);
			cy = py + (cy * cos + cx * sin);
			cx = temp;
			temp = px + (dx * cos - dy * sin);
			dy = py + (dy * cos + dx * sin);
			dx = temp;
			if(debugCorners) {
				var x = ax - 6.;
				var y = ay - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -65536;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = bx - 6.;
				var y = by - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -16711936;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 0;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = cx - 6.;
				var y = cy - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -16776961;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 0;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x = dx - 6.;
				var y = dy - 6.;
				var p = x | 0;
				var xx = p;
				var q = y | 0;
				var maxX = x + 12 | 0;
				var maxY = y + 12 | 0;
				while(true) {
					var x = p++;
					var this1 = -1048336;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelShape.transparent) {
						var location = pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0;
						var this2 = pixelShape.image[location];
						var this3 = this2;
						var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 240;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 240;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelShape.image[pixelShape.useVirtualPos ? (q - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : q * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
			}
			var soft = soft1;
			var softAB1 = softAB;
			var softBC1 = softBC;
			var softCD1 = softCD;
			var softDA1 = softDA;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softDA1 == null) {
				softDA1 = true;
			}
			if(softCD1 == null) {
				softCD1 = true;
			}
			if(softBC1 == null) {
				softBC1 = true;
			}
			if(softAB1 == null) {
				softAB1 = true;
			}
			if(soft == null) {
				soft = 40;
			}
			var soft3 = soft;
			var softAB = softAB1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						if(softAB) {
							if(softBC) {
								if(softCA) {
									var min1 = ratioA < ratioB ? ratioA : ratioB;
									if(!(min1 < ratioC)) {
										min1 = ratioC;
									}
									var max1 = ratioA > ratioB ? ratioA : ratioB;
									if(!(max1 > ratioC)) {
										max1 = ratioC;
									}
									max1 = (1 - max1) / 2;
									var min2 = min1 < max1 ? min1 : (max1 + min1) / 2;
									var i = aA * soft3 * min2 | 0;
									if(i > 255) {
										i = 255;
									}
									if(i < 0) {
										i = 0;
									}
									var this1 = i;
									a = this1;
								} else {
									min = ratioB < ratioC ? ratioB : ratioC;
									max = ratioA > ratioB ? ratioA : ratioB;
									if(!(max > ratioC)) {
										max = ratioC;
									}
									max = (1 - max) / 2;
									if(!(min < max)) {
										min = (max + min) / 2;
									}
									var i1 = aA * soft3 * min | 0;
									if(i1 > 255) {
										i1 = 255;
									}
									if(i1 < 0) {
										i1 = 0;
									}
									var this2 = i1;
									a = this2;
								}
							} else if(softCA) {
								min = ratioA < ratioC ? ratioA : ratioC;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i2 = aA * soft3 * min | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this3 = i2;
								a = this3;
							} else {
								min = ratioC;
								var i3 = aA * soft3 * min | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this4 = i3;
								a = this4;
							}
						} else if(softBC) {
							if(softCA) {
								min = ratioA < ratioB ? ratioA : ratioB;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i4 = aA * soft3 * min | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this5 = i4;
								a = this5;
							} else {
								min = ratioB;
								var i5 = aA * soft3 * min | 0;
								if(i5 > 255) {
									i5 = 255;
								}
								if(i5 < 0) {
									i5 = 0;
								}
								var this6 = i5;
								a = this6;
							}
						} else if(softCA) {
							min = ratioA;
							var i6 = aA * soft3 * min | 0;
							if(i6 > 255) {
								i6 = 255;
							}
							if(i6 < 0) {
								i6 = 0;
							}
							var this7 = i6;
							a = this7;
						} else {
							var i7 = aA | 0;
							if(i7 > 255) {
								i7 = 255;
							}
							if(i7 < 0) {
								i7 = 0;
							}
							var this8 = i7;
							a = this8;
						}
						var i8 = rA | 0;
						if(i8 > 255) {
							i8 = 255;
						}
						if(i8 < 0) {
							i8 = 0;
						}
						var this9 = i8;
						r = this9;
						var i9 = gA | 0;
						if(i9 > 255) {
							i9 = 255;
						}
						if(i9 < 0) {
							i9 = 0;
						}
						var this10 = i9;
						g = this10;
						var i10 = bA | 0;
						if(i10 > 255) {
							i10 = 255;
						}
						if(i10 < 0) {
							i10 = 0;
						}
						var this11 = i10;
						b = this11;
						var location = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
						if(pixelShape.transparent && a < 254) {
							var this12 = pixelShape.image[location];
							var this13 = this12;
							var old = pixelimageXY_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var rhs = a << 24 | r << 16 | g << 8 | b;
							var this14 = old >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = old >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = old >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = old & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = rhs >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = rhs >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = rhs >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = rhs & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
							var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
							var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
							var a4 = 255 * (a3 + a2) | 0;
							var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx,by,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft;
			var softAB = softBC1;
			var softBC = softCD1;
			var softCA = false;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						if(softAB) {
							if(softBC) {
								if(softCA) {
									var min1 = ratioA < ratioB ? ratioA : ratioB;
									if(!(min1 < ratioC)) {
										min1 = ratioC;
									}
									var max1 = ratioA > ratioB ? ratioA : ratioB;
									if(!(max1 > ratioC)) {
										max1 = ratioC;
									}
									max1 = (1 - max1) / 2;
									var min2 = min1 < max1 ? min1 : (max1 + min1) / 2;
									var i = aA * soft3 * min2 | 0;
									if(i > 255) {
										i = 255;
									}
									if(i < 0) {
										i = 0;
									}
									var this1 = i;
									a = this1;
								} else {
									min = ratioB < ratioC ? ratioB : ratioC;
									max = ratioA > ratioB ? ratioA : ratioB;
									if(!(max > ratioC)) {
										max = ratioC;
									}
									max = (1 - max) / 2;
									if(!(min < max)) {
										min = (max + min) / 2;
									}
									var i1 = aA * soft3 * min | 0;
									if(i1 > 255) {
										i1 = 255;
									}
									if(i1 < 0) {
										i1 = 0;
									}
									var this2 = i1;
									a = this2;
								}
							} else if(softCA) {
								min = ratioA < ratioC ? ratioA : ratioC;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i2 = aA * soft3 * min | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this3 = i2;
								a = this3;
							} else {
								min = ratioC;
								var i3 = aA * soft3 * min | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this4 = i3;
								a = this4;
							}
						} else if(softBC) {
							if(softCA) {
								min = ratioA < ratioB ? ratioA : ratioB;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i4 = aA * soft3 * min | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this5 = i4;
								a = this5;
							} else {
								min = ratioB;
								var i5 = aA * soft3 * min | 0;
								if(i5 > 255) {
									i5 = 255;
								}
								if(i5 < 0) {
									i5 = 0;
								}
								var this6 = i5;
								a = this6;
							}
						} else if(softCA) {
							min = ratioA;
							var i6 = aA * soft3 * min | 0;
							if(i6 > 255) {
								i6 = 255;
							}
							if(i6 < 0) {
								i6 = 0;
							}
							var this7 = i6;
							a = this7;
						} else {
							var i7 = aA | 0;
							if(i7 > 255) {
								i7 = 255;
							}
							if(i7 < 0) {
								i7 = 0;
							}
							var this8 = i7;
							a = this8;
						}
						var i8 = rA | 0;
						if(i8 > 255) {
							i8 = 255;
						}
						if(i8 < 0) {
							i8 = 0;
						}
						var this9 = i8;
						r = this9;
						var i9 = gA | 0;
						if(i9 > 255) {
							i9 = 255;
						}
						if(i9 < 0) {
							i9 = 0;
						}
						var this10 = i9;
						g = this10;
						var i10 = bA | 0;
						if(i10 > 255) {
							i10 = 255;
						}
						if(i10 < 0) {
							i10 = 0;
						}
						var this11 = i10;
						b = this11;
						var location = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
						if(pixelShape.transparent && a < 254) {
							var this12 = pixelShape.image[location];
							var this13 = this12;
							var old = pixelimageXY_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var rhs = a << 24 | r << 16 | g << 8 | b;
							var this14 = old >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = old >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = old >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = old & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = rhs >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = rhs >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = rhs >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = rhs & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
							var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
							var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
							var a4 = 255 * (a3 + a2) | 0;
							var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit == false) {
				var v = new pixelimageXY_algo_HitTri(bx,by,cx,cy,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			if(hasHit1 == true) {
				var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
			}
		}
		return pixelShape;
	}
	,__class__: pixelimageXY_triangleGML_LineShape
});
var triangleGML_shape_picture_NineSlicePicture_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,initWid,initHi,initLeft,initTop,initFat,initTall,newWid,newHi,newLeft,newTop,newFat,newTall,imageTexture,pictureX,pictureY,pictureWidth,pictureHeight,rounded) {
	if(rounded == null) {
		rounded = false;
	}
	if(pictureHeight == null) {
		pictureHeight = 0.;
	}
	if(pictureWidth == null) {
		pictureWidth = 0.;
	}
	if(pictureY == null) {
		pictureY = 0.;
	}
	if(pictureX == null) {
		pictureX = 0.;
	}
	if(newTall == null) {
		newTall = 3.;
	}
	if(newFat == null) {
		newFat = 3.;
	}
	if(newTop == null) {
		newTop = 0.5;
	}
	if(newLeft == null) {
		newLeft = 0.5;
	}
	if(newHi == null) {
		newHi = 4.;
	}
	if(newWid == null) {
		newWid = 4.;
	}
	if(initTall == null) {
		initTall = 2.;
	}
	if(initFat == null) {
		initFat = 2.;
	}
	if(initTop == null) {
		initTop = 1.;
	}
	if(initLeft == null) {
		initLeft = 1.;
	}
	if(initHi == null) {
		initHi = 4.;
	}
	if(initWid == null) {
		initWid = 4.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_FillForm.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.initWid = initWid;
	this.initHi = initHi;
	this.initLeft = initLeft;
	this.initTop = initTop;
	this.initFat = initFat;
	this.initTall = initTall;
	this.newWid = newWid;
	this.newHi = newHi;
	this.newLeft = newLeft;
	this.newTop = newTop;
	this.newFat = newFat;
	this.newTall = newTall;
	this.imageTexture = imageTexture;
	this.pictureX = pictureX;
	this.pictureY = pictureY;
	this.pictureWidth = pictureWidth;
	this.pictureHeight = pictureHeight;
	this.rounded = rounded;
};
triangleGML_shape_picture_NineSlicePicture_$.__name__ = "triangleGML.shape.picture.NineSlicePicture_";
triangleGML_shape_picture_NineSlicePicture_$.__super__ = triangleGML_FillForm;
triangleGML_shape_picture_NineSlicePicture_$.prototype = $extend(triangleGML_FillForm.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "initFat":
			this.initFat = parseFloat(value);
			break;
		case "initHi":
			this.initHi = parseFloat(value);
			break;
		case "initLeft":
			this.initLeft = parseFloat(value);
			break;
		case "initTall":
			this.initTall = parseFloat(value);
			break;
		case "initTop":
			this.initTop = parseFloat(value);
			break;
		case "initWid":
			this.initWid = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "newFat":
			this.newFat = parseFloat(value);
			break;
		case "newHi":
			this.newHi = parseFloat(value);
			break;
		case "newLeft":
			this.newLeft = parseFloat(value);
			break;
		case "newTall":
			this.newTall = parseFloat(value);
			break;
		case "newTop":
			this.newTop = parseFloat(value);
			break;
		case "newWid":
			this.newWid = parseFloat(value);
			break;
		case "pictureHeight":
			this.pictureHeight = parseFloat(value);
			break;
		case "pictureWidth":
			this.pictureWidth = parseFloat(value);
			break;
		case "pictureX":
			this.pictureX = parseFloat(value);
			break;
		case "pictureY":
			this.pictureY = parseFloat(value);
			break;
		case "rounded":
			this.rounded = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		default:
			triangleGML_FillForm.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: triangleGML_shape_picture_NineSlicePicture_$
});
var pixelimageXY_triangleGML_NineSlicePicture = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,initWid,initHi,initLeft,initTop,initFat,initTall,newWid,newHi,newLeft,newTop,newFat,newTall,imageTexture,pictureX,pictureY,pictureWidth,pictureHeight,rounded) {
	triangleGML_shape_picture_NineSlicePicture_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,initWid,initHi,initLeft,initTop,initFat,initTall,newWid,newHi,newLeft,newTop,newFat,newTall,imageTexture,pictureX,pictureY,pictureWidth,pictureHeight,rounded);
};
pixelimageXY_triangleGML_NineSlicePicture.__name__ = "pixelimageXY.triangleGML.NineSlicePicture";
pixelimageXY_triangleGML_NineSlicePicture.__super__ = triangleGML_shape_picture_NineSlicePicture_$;
pixelimageXY_triangleGML_NineSlicePicture.prototype = $extend(triangleGML_shape_picture_NineSlicePicture_$.prototype,{
	render: function(pixelShape) {
		if(this.imageTexture != null) {
			var win_x = 0;
			var win_y = 0;
			var win_width = this.imageTexture.width;
			var win_height = this.imageTexture.height;
			win_x = this.pictureX;
			win_y = this.pictureY;
			if(this.pictureWidth != 0.) {
				win_width = this.pictureWidth;
			}
			if(this.pictureHeight != 0.) {
				win_height = this.pictureHeight;
			}
			if(this.rounded != true) {
				var texture = this.imageTexture;
				var x = this.left;
				var y = this.top;
				var wid = this.initWid;
				var hi = this.initHi;
				var left = this.initLeft;
				var top = this.initTop;
				var fat = this.initFat;
				var tall = this.initTall;
				var widNew = this.newWid;
				var hiNew = this.newHi;
				var leftNew = this.newLeft;
				var topNew = this.newTop;
				var fatNew = this.newFat;
				var tallNew = this.newTall;
				var w = wid | 0;
				var h = hi | 0;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				var temp = this2;
				temp.transparent = false;
				var hasHit = false;
				if(hasHit == null) {
					hasHit = false;
				}
				var ax = 0;
				var ay = 0;
				var bx = ax + widNew;
				var by = 0;
				var cx = bx;
				var cy = ay + hiNew;
				var dx = 0;
				var dy = cx;
				var rightW = widNew - leftNew - fatNew;
				var bottomH = hiNew - topNew - tallNew;
				var leftX = leftNew;
				var topY = topNew;
				var rightX = leftNew + fatNew;
				var bottomY = topNew + tallNew;
				var au = 0.;
				var av = 0.;
				var bu = 0.;
				var cv = 0.;
				var sw = 1 / (wid + 1);
				var sh = 1 / (hi + 1);
				bu = left * sw;
				cv = top * sh;
				var au1 = 0.;
				var av1 = 0.;
				var bu1 = bu;
				var bv = 0.;
				var cu = bu;
				var cv1 = cv;
				var du = 0.;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = leftX;
				var bcy = 0 - topY;
				var acx = 0;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(0 > leftX) {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else if(leftX > 0) {
					var ii_min = Math.ceil(0);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(0 > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(0,0,leftX,0,0,topY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = leftX;
				var bcy = topY - topY;
				var acx = leftX;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > leftX) {
					if(leftX > 0) {
						var ii_min = leftX > 0 ? Math.floor(0) : Math.floor(leftX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(leftX);
						var ii_max = Math.ceil(0);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(leftX > 0) {
					var ii_min = leftX > 0 ? Math.floor(0) : Math.ceil(leftX);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(0 > topY) {
					if(0 > topY) {
						var ii_min = topY > topY ? Math.floor(topY) : Math.floor(topY);
						var ii_max = Math.ceil(0);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(topY);
						var ii_max = Math.ceil(topY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(topY > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(topY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(leftX,0,leftX,topY,0,topY,true);
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitQuad(0,0,leftX,0,leftX,topY,0,topY,true);
				}
				au = bu;
				bu = (left + fat) * sw;
				var au1 = au;
				var av1 = 0.;
				var bu1 = bu;
				var bv = 0.;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = rightX - leftX;
				var bcy = 0 - topY;
				var acx = leftX - leftX;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > rightX) {
					if(leftX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(rightX > leftX) {
					var ii_min = leftX > leftX ? Math.floor(leftX) : Math.ceil(leftX);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(0 > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(leftX,0,rightX,0,leftX,topY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = rightX - leftX;
				var bcy = topY - topY;
				var acx = rightX - leftX;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > rightX) {
					if(rightX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(rightX > leftX) {
					var ii_min = rightX > leftX ? Math.floor(leftX) : Math.ceil(rightX);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(0 > topY) {
					if(0 > topY) {
						var ii_min = topY > topY ? Math.floor(topY) : Math.floor(topY);
						var ii_max = Math.ceil(0);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(topY);
						var ii_max = Math.ceil(topY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(topY > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(topY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(rightX,0,rightX,topY,leftX,topY,true);
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitQuad(leftX,0,rightX,0,rightX,topY,leftX,topY,true);
				}
				au = bu;
				bu = 1.;
				var bx1 = widNew;
				var cx1 = widNew;
				var au1 = au;
				var av1 = 0.;
				var bu1 = bu;
				var bv = 0;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = bx1 - rightX;
				var bcy = 0 - topY;
				var acx = rightX - rightX;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > bx1) {
					if(rightX > rightX) {
						var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(bx1 > rightX) {
					var ii_min = rightX > rightX ? Math.floor(rightX) : Math.ceil(rightX);
					var ii_max = Math.ceil(bx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(0 > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(rightX,0,bx1,0,rightX,topY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = cx1 - rightX;
				var bcy = topY - topY;
				var acx = bx1 - rightX;
				var acy = 0 - topY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(bx1 > cx1) {
					if(bx1 > rightX) {
						var ii_min = cx1 > rightX ? Math.floor(rightX) : Math.floor(cx1);
						var ii_max = Math.ceil(bx1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(cx1);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(cx1 > rightX) {
					var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.ceil(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(0 > topY) {
					if(0 > topY) {
						var ii_min = topY > topY ? Math.floor(topY) : Math.floor(topY);
						var ii_max = Math.ceil(0);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(topY);
						var ii_max = Math.ceil(topY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(topY > topY) {
					var ii_min = 0 > topY ? Math.floor(topY) : Math.ceil(0);
					var ii_max = Math.ceil(topY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(topY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - topY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(bx1,0,cx1,topY,rightX,topY,true);
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitQuad(rightX,0,bx1,0,cx1,topY,rightX,topY,true);
				}
				av = top * sh;
				bu = left * sw;
				cv = (top + tall) * sh;
				var ay1 = topY - 1;
				var by1 = topY - 1;
				var cy1 = bottomY + 1;
				var au1 = 0.;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = 0.;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = leftX;
				var bcy = by1 - bottomY;
				var acx = 0;
				var acy = ay1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(0 > leftX) {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else if(leftX > 0) {
					var ii_min = Math.ceil(0);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(ay1 > by1) {
					if(ay1 > bottomY) {
						var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.floor(by1);
						var ii_max = Math.ceil(ay1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(by1 > bottomY) {
					var ii_min = ay1 > bottomY ? Math.floor(bottomY) : Math.ceil(ay1);
					var ii_max = Math.ceil(by1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(ay1);
					var ii_max = Math.ceil(bottomY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(0,ay1,leftX,by1,0,bottomY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = leftX;
				var bcy = cy1 - bottomY;
				var acx = leftX;
				var acy = by1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > leftX) {
					if(leftX > 0) {
						var ii_min = leftX > 0 ? Math.floor(0) : Math.floor(leftX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(leftX);
						var ii_max = Math.ceil(0);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(leftX > 0) {
					var ii_min = leftX > 0 ? Math.floor(0) : Math.ceil(leftX);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(by1 > cy1) {
					if(by1 > bottomY) {
						var ii_min = cy1 > bottomY ? Math.floor(bottomY) : Math.floor(cy1);
						var ii_max = Math.ceil(by1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(cy1 > bottomY) {
					var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.ceil(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(bottomY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(leftX,by1,leftX,cy1,0,bottomY,true);
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitQuad(0,ay1,leftX,by1,leftX,cy1,0,bottomY,true);
				}
				au = bu;
				bu = (left + fat) * sw;
				var ay1 = topY - 1;
				var by1 = topY - 1;
				var cy1 = bottomY + 1;
				var au1 = au;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = rightX - leftX;
				var bcy = by1 - bottomY;
				var acx = leftX - leftX;
				var acy = ay1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > rightX) {
					if(leftX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(rightX > leftX) {
					var ii_min = leftX > leftX ? Math.floor(leftX) : Math.ceil(leftX);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(ay1 > by1) {
					if(ay1 > bottomY) {
						var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.floor(by1);
						var ii_max = Math.ceil(ay1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(by1 > bottomY) {
					var ii_min = ay1 > bottomY ? Math.floor(bottomY) : Math.ceil(ay1);
					var ii_max = Math.ceil(by1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(ay1);
					var ii_max = Math.ceil(bottomY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(leftX,ay1,rightX,by1,leftX,bottomY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = rightX - leftX;
				var bcy = cy1 - bottomY;
				var acx = rightX - leftX;
				var acy = by1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > rightX) {
					if(rightX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(rightX > leftX) {
					var ii_min = rightX > leftX ? Math.floor(leftX) : Math.ceil(rightX);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(by1 > cy1) {
					if(by1 > bottomY) {
						var ii_min = cy1 > bottomY ? Math.floor(bottomY) : Math.floor(cy1);
						var ii_max = Math.ceil(by1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(cy1 > bottomY) {
					var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.ceil(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(bottomY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(rightX,by1,rightX,cy1,leftX,bottomY,true);
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitQuad(leftX,ay1,rightX,by1,rightX,cy1,leftX,bottomY,true);
				}
				au = bu;
				bu = 1.;
				var ay1 = topY - 1;
				var bx1 = widNew;
				var by1 = topY - 1;
				var cx1 = widNew;
				var cy1 = bottomY + 1;
				var au1 = au;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = bx1 - rightX;
				var bcy = by1 - bottomY;
				var acx = rightX - rightX;
				var acy = ay1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > bx1) {
					if(rightX > rightX) {
						var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(bx1 > rightX) {
					var ii_min = rightX > rightX ? Math.floor(rightX) : Math.ceil(rightX);
					var ii_max = Math.ceil(bx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(ay1 > by1) {
					if(ay1 > bottomY) {
						var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.floor(by1);
						var ii_max = Math.ceil(ay1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(by1);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(by1 > bottomY) {
					var ii_min = ay1 > bottomY ? Math.floor(bottomY) : Math.ceil(ay1);
					var ii_max = Math.ceil(by1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(ay1);
					var ii_max = Math.ceil(bottomY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(rightX,ay1,bx1,by1,rightX,bottomY,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = cx1 - rightX;
				var bcy = cy1 - bottomY;
				var acx = bx1 - rightX;
				var acy = by1 - bottomY;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(bx1 > cx1) {
					if(bx1 > rightX) {
						var ii_min = cx1 > rightX ? Math.floor(rightX) : Math.floor(cx1);
						var ii_max = Math.ceil(bx1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(cx1);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(cx1 > rightX) {
					var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.ceil(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(by1 > cy1) {
					if(by1 > bottomY) {
						var ii_min = cy1 > bottomY ? Math.floor(bottomY) : Math.floor(cy1);
						var ii_max = Math.ceil(by1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(cy1 > bottomY) {
					var ii_min = by1 > bottomY ? Math.floor(bottomY) : Math.ceil(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(bottomY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - bottomY;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(bx1,by1,cx1,cy1,rightX,bottomY,true);
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitQuad(rightX,ay1,bx1,by1,cx1,cy1,rightX,bottomY,true);
				}
				av = (top + tall) * sh;
				bu = left * sw;
				cv = 1.;
				var cy1 = hiNew;
				var dy1 = hiNew;
				var au1 = 0.;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = 0.;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = leftX;
				var bcy = bottomY - dy1;
				var acx = 0;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(0 > leftX) {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else if(leftX > 0) {
					var ii_min = Math.ceil(0);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(0);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(bottomY > bottomY) {
					if(bottomY > dy1) {
						var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.floor(bottomY);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(bottomY);
						var ii_max = Math.ceil(dy1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(bottomY > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(bottomY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(0,bottomY,leftX,bottomY,0,dy1,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = leftX;
				var bcy = cy1 - dy1;
				var acx = leftX;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > leftX) {
					if(leftX > 0) {
						var ii_min = leftX > 0 ? Math.floor(0) : Math.floor(leftX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(leftX);
						var ii_max = Math.ceil(0);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(leftX > 0) {
					var ii_min = leftX > 0 ? Math.floor(0) : Math.ceil(leftX);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(0);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(bottomY > cy1) {
					if(bottomY > dy1) {
						var ii_min = cy1 > dy1 ? Math.floor(dy1) : Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(dy1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(cy1 > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(leftX,bottomY,leftX,cy1,0,dy1,true);
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitQuad(0,bottomY,leftX,bottomY,leftX,cy1,0,dy1,true);
				}
				au = bu;
				bu = (left + fat) * sw;
				var cy1 = hiNew;
				var dy1 = hiNew;
				var au1 = au;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au2 = au1;
				var av2 = av1;
				var bu2 = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au2;
				au2 = bu2;
				bu2 = temp1;
				temp1 = av2;
				av2 = bv1;
				bv1 = temp1;
				var bcx = rightX - leftX;
				var bcy = bottomY - dy1;
				var acx = leftX - leftX;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(leftX > rightX) {
					if(leftX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(rightX > leftX) {
					var ii_min = leftX > leftX ? Math.floor(leftX) : Math.ceil(leftX);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(leftX);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(bottomY > bottomY) {
					if(bottomY > dy1) {
						var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.floor(bottomY);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(bottomY);
						var ii_max = Math.ceil(dy1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(bottomY > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(bottomY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au2 * ratioA + bu2 * ratioB + du * ratioC;
							var v = av2 * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(leftX,bottomY,rightX,bottomY,leftX,dy1,true);
				}
				var au1 = bu1;
				var av1 = bv;
				var bu1 = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au1;
				au1 = bu1;
				bu1 = temp1;
				temp1 = av1;
				av1 = bv;
				bv = temp1;
				var bcx = rightX - leftX;
				var bcy = cy1 - dy1;
				var acx = rightX - leftX;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > rightX) {
					if(rightX > leftX) {
						var ii_min = rightX > leftX ? Math.floor(leftX) : Math.floor(rightX);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(rightX);
						var ii_max = Math.ceil(leftX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(rightX > leftX) {
					var ii_min = rightX > leftX ? Math.floor(leftX) : Math.ceil(rightX);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(leftX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(bottomY > cy1) {
					if(bottomY > dy1) {
						var ii_min = cy1 > dy1 ? Math.floor(dy1) : Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(dy1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(cy1 > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - leftX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au1 * ratioA + bu1 * ratioB + du * ratioC;
							var v = av1 * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(rightX,bottomY,rightX,cy1,leftX,dy1,true);
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitQuad(leftX,bottomY,rightX,bottomY,rightX,cy1,leftX,dy1,true);
				}
				au = bu;
				bu = 1.;
				var bx1 = widNew;
				var cx1 = widNew;
				var cy1 = hiNew;
				var dy1 = hiNew;
				var au1 = au;
				var av1 = av;
				var bu1 = bu;
				var bv = av;
				var cu = bu;
				var cv1 = cv;
				var du = au;
				var dv = cv;
				var hasHit1 = hasHit;
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				if(dv == null) {
					dv = 1.;
				}
				if(du == null) {
					du = 0.;
				}
				if(cv1 == null) {
					cv1 = 1.;
				}
				if(cu == null) {
					cu = 1.;
				}
				if(bv == null) {
					bv = 0.;
				}
				if(bu1 == null) {
					bu1 = 1.;
				}
				if(av1 == null) {
					av1 = 0.;
				}
				if(au1 == null) {
					au1 = 0.;
				}
				var au = au1;
				var av = av1;
				var bu = bu1;
				var bv1 = bv;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au;
				au = bu;
				bu = temp1;
				temp1 = av;
				av = bv1;
				bv1 = temp1;
				var bcx = bx1 - rightX;
				var bcy = bottomY - dy1;
				var acx = rightX - rightX;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(rightX > bx1) {
					if(rightX > rightX) {
						var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(bx1);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(bx1 > rightX) {
					var ii_min = rightX > rightX ? Math.floor(rightX) : Math.ceil(rightX);
					var ii_max = Math.ceil(bx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(rightX);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(bottomY > bottomY) {
					if(bottomY > dy1) {
						var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.floor(bottomY);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(bottomY);
						var ii_max = Math.ceil(dy1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(bottomY > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(bottomY);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au * ratioA + bu * ratioB + du * ratioC;
							var v = av * ratioA + bv1 * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(rightX,bottomY,bx1,bottomY,rightX,dy1,true);
				}
				var au = bu1;
				var av = bv;
				var bu = cu;
				var bv = cv1;
				var hasHit2 = hasHit1;
				if(hasHit2 == null) {
					hasHit2 = false;
				}
				var temp1 = au;
				au = bu;
				bu = temp1;
				temp1 = av;
				av = bv;
				bv = temp1;
				var bcx = cx1 - rightX;
				var bcy = cy1 - dy1;
				var acx = bx1 - rightX;
				var acy = bottomY - dy1;
				var dot11 = bcx * bcx + bcy * bcy;
				var dot12 = bcx * acx + bcy * acy;
				var dot22 = acx * acx + acy * acy;
				var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
				var xIter3;
				if(bx1 > cx1) {
					if(bx1 > rightX) {
						var ii_min = cx1 > rightX ? Math.floor(rightX) : Math.floor(cx1);
						var ii_max = Math.ceil(bx1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min = Math.floor(cx1);
						var ii_max = Math.ceil(rightX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					}
				} else if(cx1 > rightX) {
					var ii_min = bx1 > rightX ? Math.floor(rightX) : Math.ceil(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(rightX);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
				var yIter3;
				if(bottomY > cy1) {
					if(bottomY > dy1) {
						var ii_min = cy1 > dy1 ? Math.floor(dy1) : Math.floor(cy1);
						var ii_max = Math.ceil(bottomY);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					} else {
						var ii_min = Math.floor(cy1);
						var ii_max = Math.ceil(dy1);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						yIter3 = this1;
					}
				} else if(cy1 > dy1) {
					var ii_min = bottomY > dy1 ? Math.floor(dy1) : Math.ceil(bottomY);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(bottomY);
					var ii_max = Math.ceil(dy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
				var undoImage = null;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var px = _g_min++;
					var pcx = px - rightX;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var py = _g_min1++;
						var pcy = py - dy1;
						var dot31 = pcx * bcx + pcy * bcy;
						var dot32 = pcx * acx + pcy * acy;
						var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
						var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
						var ratioC = 1.0 - ratioB - ratioA;
						if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
							var u = au * ratioA + bu * ratioB + du * ratioC;
							var v = av * ratioA + bv * ratioB + dv * ratioC;
							var x1 = u * win_width + win_x | 0;
							var y1 = v * win_height + win_y | 0;
							var c = texture.image[texture.useVirtualPos ? (y1 - texture.virtualY) * texture.width + x1 - texture.virtualX | 0 : y1 * texture.width + x1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							var this1 = col;
							var c1 = this1;
							if((c1 >> 24 & 255) < 254 && temp.transparent) {
								var location = temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0;
								var this2 = temp.image[location];
								var this3 = this2;
								var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
								var this5 = this4 >> 24 & 255;
								var a1 = this5 == 0 ? 0. : this5 / 255;
								var this6 = this4 >> 16 & 255;
								var r1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this4 >> 8 & 255;
								var g1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this4 & 255;
								var b1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = col >> 24 & 255;
								var a2 = this9 == 0 ? 0. : this9 / 255;
								var this10 = col >> 16 & 255;
								var r2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = col >> 8 & 255;
								var g2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = col & 255;
								var b2 = this12 == 0 ? 0. : this12 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								temp.image[temp.useVirtualPos ? (py - temp.virtualY) * temp.width + px - temp.virtualX | 0 : py * temp.width + px | 0] = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							}
						}
					}
				}
				if(hasHit2 == false) {
					var v = new pixelimageXY_algo_HitTri(bx1,bottomY,cx1,cy1,rightX,dy1,true);
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitQuad(rightX,bottomY,bx1,bottomY,cx1,cy1,rightX,dy1,true);
				}
				var hit;
				if(hasHit == true) {
					var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
					hit = v;
				} else {
					hit = null;
				}
				var x1 = x | 0;
				var y1 = y | 0;
				var _g = 0;
				var _g1 = temp.height;
				while(_g < _g1) {
					var dy = _g++;
					var _g2 = 0;
					var _g3 = temp.width;
					while(_g2 < _g3) {
						var dx = _g2++;
						var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(temp.useMask && temp.mask != null) {
							var this1 = temp.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x2 = x1 + dx;
							var y2 = y1 + dy;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && pixelShape.transparent) {
								var location = pixelShape.useVirtualPos ? (y2 - pixelShape.virtualY) * pixelShape.width + x2 - pixelShape.virtualX | 0 : y2 * pixelShape.width + x2 | 0;
								var this11 = pixelShape.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[pixelShape.useVirtualPos ? (y2 - pixelShape.virtualY) * pixelShape.width + x2 - pixelShape.virtualX | 0 : y2 * pixelShape.width + x2 | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
				temp = null;
				if(hit != null) {
					hit.ax += x;
					hit.ay += y;
					hit.bx += x;
					hit.by += y;
					hit.cx += x;
					hit.cy += y;
					hit.dx += x;
					hit.dy += y;
				}
			} else {
				throw haxe_Exception.thrown("not yet implemented");
			}
		}
		return pixelShape;
	}
	,setImage: function(name,value) {
		if(name.toLowerCase() == "imagetexture") {
			if(value == null) {
				throw haxe_Exception.thrown("failed to find image resource" + name);
			}
			this.imageTexture = value;
		}
		return value;
	}
	,__class__: pixelimageXY_triangleGML_NineSlicePicture
});
var triangleGML_shape_contour_QuadShape_$ = function(opacity,visibility,strokeColor,aX,aY,bX,bY,cX,cY,dX,dY) {
	if(dY == null) {
		dY = 1.;
	}
	if(dX == null) {
		dX = 0.;
	}
	if(cY == null) {
		cY = 1.;
	}
	if(cX == null) {
		cX = 1.;
	}
	if(bY == null) {
		bY = 0.;
	}
	if(bX == null) {
		bX = 1.;
	}
	if(aY == null) {
		aY = 0.;
	}
	if(aX == null) {
		aX = 0.;
	}
	if(strokeColor == null) {
		strokeColor = -1048576;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_BasicShape.call(this,opacity,visibility,strokeColor,0.,null);
	this.aX = aX;
	this.aY = aY;
	this.bX = bX;
	this.bY = bY;
	this.cX = cX;
	this.cY = cY;
	this.dX = dX;
	this.dY = dY;
};
triangleGML_shape_contour_QuadShape_$.__name__ = "triangleGML.shape.contour.QuadShape_";
triangleGML_shape_contour_QuadShape_$.__super__ = triangleGML_BasicShape;
triangleGML_shape_contour_QuadShape_$.prototype = $extend(triangleGML_BasicShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "aX":
			this.aX = parseFloat(value);
			break;
		case "aY":
			this.aY = parseFloat(value);
			break;
		case "bX":
			this.bX = parseFloat(value);
			break;
		case "bY":
			this.bY = parseFloat(value);
			break;
		case "cX":
			this.cX = parseFloat(value);
			break;
		case "cY":
			this.cY = parseFloat(value);
			break;
		case "dX":
			this.dX = parseFloat(value);
			break;
		case "dY":
			this.dY = parseFloat(value);
			break;
		default:
			triangleGML_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: triangleGML_shape_contour_QuadShape_$
});
var pixelimageXY_triangleGML_QuadShape = function(opacity,visibility,strokeColor,aX,aY,bX,bY,cX,cY,dX,dY) {
	triangleGML_shape_contour_QuadShape_$.call(this,opacity,visibility,strokeColor,aX,aY,bX,bY,cX,cY,dX,dY);
};
pixelimageXY_triangleGML_QuadShape.__name__ = "pixelimageXY.triangleGML.QuadShape";
pixelimageXY_triangleGML_QuadShape.__super__ = triangleGML_shape_contour_QuadShape_$;
pixelimageXY_triangleGML_QuadShape.prototype = $extend(triangleGML_shape_contour_QuadShape_$.prototype,{
	setParameter: function(name,value) {
		if(name == "luxury") {
			this.luxury = StringTools.trim(value).toLowerCase() == "true";
		} else {
			triangleGML_shape_contour_QuadShape_$.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelShape) {
		var tmp;
		if(this.edgeSoft == 0.) {
			var ax = this.aX + this.offX;
			var ay = this.aY + this.offY;
			var bx = this.bX + this.offX;
			var by = this.bY + this.offY;
			var cx = this.cX + this.offX;
			var cy = this.cY + this.offY;
			var dx = this.dX + this.offX;
			var dy = this.dY + this.offY;
			var color = this.strokeColor;
			var hasHit = true;
			if(hasHit == null) {
				hasHit = false;
			}
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(ax > bx1) {
				if(ax > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx1 > cx1) {
				var ii_min = ax > cx1 ? Math.floor(cx1) : Math.ceil(ax);
				var ii_max = Math.ceil(bx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by1) {
				if(ay > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by1 > cy1) {
				var ii_min = ay > cy1 ? Math.floor(cy1) : Math.ceil(ay);
				var ii_max = Math.ceil(by1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(pixelShape.useMask && pixelShape.mask != null) {
							var this1 = pixelShape.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && pixelShape.transparent) {
							var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
							var this2 = pixelShape.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			var bx1 = cx;
			var by1 = cy;
			var cx1 = dx;
			var cy1 = dy;
			var hasHit = hasHit1;
			if(hasHit == null) {
				hasHit = false;
			}
			var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy1 - cx1 * by1) + (cx1 * by - bx * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var hasHit2 = hasHit;
			var hasUndo = false;
			if(hasUndo == null) {
				hasUndo = false;
			}
			if(hasHit2 == null) {
				hasHit2 = false;
			}
			var s0 = by * cx1 - bx * cy1;
			var sx = cy1 - by;
			var sy = bx - cx1;
			var t0 = bx * by1 - by * bx1;
			var tx = by - by1;
			var ty = bx1 - bx;
			var A = -by1 * cx1 + by * (-bx1 + cx1) + bx * (by1 - cy1) + bx1 * cy1;
			var xIter3;
			if(bx > bx1) {
				if(bx > cx1) {
					var ii_min = bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1);
					var ii_max = Math.ceil(bx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx1);
					var ii_max = Math.ceil(cx1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx1 > cx1) {
				var ii_min = bx > cx1 ? Math.floor(cx1) : Math.ceil(bx);
				var ii_max = Math.ceil(bx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(cx1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(by > by1) {
				if(by > cy1) {
					var ii_min = by1 > cy1 ? Math.floor(cy1) : Math.floor(by1);
					var ii_max = Math.ceil(by);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by1);
					var ii_max = Math.ceil(cy1);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by1 > cy1) {
				var ii_min = by > cy1 ? Math.floor(cy1) : Math.ceil(by);
				var ii_max = Math.ceil(by1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(cy1);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			if(hasUndo) {
				var w = xIter3.max - xIter3.start + 1;
				var h = yIter3.max - yIter3.start + 1;
				var this1 = new Uint32Array(w * h | 0);
				var this2 = new pixelimageXY_ImageStruct(w,h,this1);
				undoImage = this2;
				var rectLeft = xIter3.start;
				var rectTop = yIter3.start;
				var rectRight = xIter3.max;
				var _g = rectTop;
				var _g1 = yIter3.max;
				while(_g < _g1) {
					var dy1 = _g++;
					var _g2 = rectLeft;
					var _g3 = rectRight;
					while(_g2 < _g3) {
						var dx1 = _g2++;
						var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
						var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						if(pixelShape.useMask && pixelShape.mask != null) {
							var this1 = pixelShape.mask;
							var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
							var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
							var maskPixel = this2;
							var this3 = col;
							var this4 = this3;
							if(maskPixel == 0) {
								var this5 = this4;
								col = this5;
							} else {
								var this6 = maskPixel >> 24 & 255;
								var m0 = this6 == 0 ? 0. : this6 / 255;
								var this7 = maskPixel >> 16 & 255;
								var m1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = maskPixel >> 8 & 255;
								var m2 = this8 == 0 ? 0. : this8 / 255;
								var this9 = maskPixel & 255;
								var m3 = this9 == 0 ? 0. : this9 / 255;
								var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
								var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
								var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
								var ch3 = (1. - m3) * (this4 & 255) | 0;
								col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
							}
						}
						if(col != 0) {
							var x = dx1 - rectLeft;
							var y = dy1 - rectTop;
							var this10 = col;
							var c2 = this10;
							if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
								var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
								var this11 = undoImage.image[location];
								var this12 = this11;
								var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
								var this14 = this13 >> 24 & 255;
								var a1 = this14 == 0 ? 0. : this14 / 255;
								var this15 = this13 >> 16 & 255;
								var r1 = this15 == 0 ? 0. : this15 / 255;
								var this16 = this13 >> 8 & 255;
								var g1 = this16 == 0 ? 0. : this16 / 255;
								var this17 = this13 & 255;
								var b1 = this17 == 0 ? 0. : this17 / 255;
								var this18 = col >> 24 & 255;
								var a2 = this18 == 0 ? 0. : this18 / 255;
								var this19 = col >> 16 & 255;
								var r2 = this19 == 0 ? 0. : this19 / 255;
								var this20 = col >> 8 & 255;
								var g2 = this20 == 0 ? 0. : this20 / 255;
								var this21 = col & 255;
								var b2 = this21 == 0 ? 0. : this21 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
							}
						}
					}
				}
			}
			var found = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var x = _g_min++;
				sxx = sx * x;
				txx = tx * x;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var y = _g_min1++;
					s = s0 + sxx + sy * y;
					t = t0 + txx + ty * y;
					if(s <= 0 || t <= 0) {
						if(found) {
							break;
						}
					} else if(s + t < A) {
						var this1 = color;
						var c = this1;
						if((c >> 24 & 255) < 254 && pixelShape.transparent) {
							var location = pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0;
							var this2 = pixelShape.image[location];
							var this3 = this2;
							var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
							var this5 = this4 >> 24 & 255;
							var a1 = this5 == 0 ? 0. : this5 / 255;
							var this6 = this4 >> 16 & 255;
							var r1 = this6 == 0 ? 0. : this6 / 255;
							var this7 = this4 >> 8 & 255;
							var g1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = this4 & 255;
							var b1 = this8 == 0 ? 0. : this8 / 255;
							var this9 = color >> 24 & 255;
							var a2 = this9 == 0 ? 0. : this9 / 255;
							var this10 = color >> 16 & 255;
							var r2 = this10 == 0 ? 0. : this10 / 255;
							var this11 = color >> 8 & 255;
							var g2 = this11 == 0 ? 0. : this11 / 255;
							var this12 = color & 255;
							var b2 = this12 == 0 ? 0. : this12 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[pixelShape.useVirtualPos ? (y - pixelShape.virtualY) * pixelShape.width + x - pixelShape.virtualX | 0 : y * pixelShape.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit2 == true) {
				var v = new pixelimageXY_algo_HitTri(bx,by,bx1,by1,cx1,cy1,true);
				if(hasUndo) {
					v.undoImage = undoImage;
					v.undoX = xIter3.start;
					v.undoY = yIter3.start;
				}
			}
			if(hasHit1 == true) {
				var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
				tmp = v;
			} else {
				tmp = null;
			}
		} else if(this.luxury) {
			var ax = this.aX + this.offX;
			var ay = this.aY + this.offY;
			var bx = this.bX + this.offX;
			var by = this.bY + this.offY;
			var cx = this.cX + this.offX;
			var cy = this.cY + this.offY;
			var dx = this.dX + this.offX;
			var dy = this.dY + this.offY;
			var color = this.strokeColor;
			var soft = this.edgeSoft;
			var softAB = true;
			var softBC = true;
			var softCD = true;
			var softDA = true;
			if(softDA == null) {
				softDA = true;
			}
			if(softCD == null) {
				softCD = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft == null) {
				soft = 40;
			}
			var soft1 = soft;
			var softAB1 = softAB;
			var softBC1 = softBC;
			var softCD1 = softCD;
			var softDA1 = softDA;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softDA1 == null) {
				softDA1 = true;
			}
			if(softCD1 == null) {
				softCD1 = true;
			}
			if(softBC1 == null) {
				softBC1 = true;
			}
			if(softAB1 == null) {
				softAB1 = true;
			}
			if(soft1 == null) {
				soft1 = 40;
			}
			var soft3 = soft1;
			var softAB = softAB1;
			var softBC = softBC1;
			var softCA = false;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - cx;
			var bcy = by - cy;
			var acx = ax - cx;
			var acy = ay - cy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > cx) {
					var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(cx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx > cx) {
				var ii_min = ax > cx ? Math.floor(cx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by) {
				if(ay > cy) {
					var ii_min = by > cy ? Math.floor(cy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(cy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by > cy) {
				var ii_min = ay > cy ? Math.floor(cy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - cx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - cy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this1 = i;
						r = this1;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this2 = i1;
						g = this2;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this3 = i2;
						b = this3;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this4 = i3;
							a = this4;
							var location = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
							if(pixelShape.transparent && a < 254) {
								var this5 = pixelShape.image[location];
								var this6 = this5;
								var old = pixelimageXY_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this7 = old >> 24 & 255;
								var a1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = old >> 16 & 255;
								var r1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 8 & 255;
								var g1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old & 255;
								var b1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = rhs >> 24 & 255;
								var a2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 16 & 255;
								var r2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 8 & 255;
								var g2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs & 255;
								var b2 = this14 == 0 ? 0. : this14 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this15 = i4;
							a = this15;
							var location1 = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
							if(pixelShape.transparent && a < 254) {
								var this16 = pixelShape.image[location1];
								var this17 = this16;
								var old1 = pixelimageXY_Endian_isLittleEndian ? (this17 >> 24 & 255) << 24 | (this17 & 255) << 16 | (this17 >> 8 & 255) << 8 | this17 >> 16 & 255 : this17;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this18 = old1 >> 24 & 255;
								var a11 = this18 == 0 ? 0. : this18 / 255;
								var this19 = old1 >> 16 & 255;
								var r11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 8 & 255;
								var g11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 & 255;
								var b11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = rhs1 >> 24 & 255;
								var a21 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 16 & 255;
								var r21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 8 & 255;
								var g21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 & 255;
								var b21 = this25 == 0 ? 0. : this25 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								pixelShape.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								pixelShape.image[location1] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx,by,cx,cy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft1;
			var softAB = softCD1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - ax;
			var bcy = cy - ay;
			var acx = dx - ax;
			var acy = dy - ay;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(dx > cx) {
				if(dx > ax) {
					var ii_min = cx > ax ? Math.floor(ax) : Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(cx > ax) {
				var ii_min = dx > ax ? Math.floor(ax) : Math.ceil(dx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(dx);
				var ii_max = Math.ceil(ax);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(dy > cy) {
				if(dy > ay) {
					var ii_min = cy > ay ? Math.floor(ay) : Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(cy > ay) {
				var ii_min = dy > ay ? Math.floor(ay) : Math.ceil(dy);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(dy);
				var ii_max = Math.ceil(ay);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - ax;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - ay;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this1 = i;
						r = this1;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this2 = i1;
						g = this2;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this3 = i2;
						b = this3;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this4 = i3;
							a = this4;
							var location = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
							if(pixelShape.transparent && a < 254) {
								var this5 = pixelShape.image[location];
								var this6 = this5;
								var old = pixelimageXY_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this7 = old >> 24 & 255;
								var a1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = old >> 16 & 255;
								var r1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 8 & 255;
								var g1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old & 255;
								var b1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = rhs >> 24 & 255;
								var a2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 16 & 255;
								var r2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 8 & 255;
								var g2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs & 255;
								var b2 = this14 == 0 ? 0. : this14 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this15 = i4;
							a = this15;
							var location1 = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
							if(pixelShape.transparent && a < 254) {
								var this16 = pixelShape.image[location1];
								var this17 = this16;
								var old1 = pixelimageXY_Endian_isLittleEndian ? (this17 >> 24 & 255) << 24 | (this17 & 255) << 16 | (this17 >> 8 & 255) << 8 | this17 >> 16 & 255 : this17;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this18 = old1 >> 24 & 255;
								var a11 = this18 == 0 ? 0. : this18 / 255;
								var this19 = old1 >> 16 & 255;
								var r11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 8 & 255;
								var g11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 & 255;
								var b11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = rhs1 >> 24 & 255;
								var a21 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 16 & 255;
								var r21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 8 & 255;
								var g21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 & 255;
								var b21 = this25 == 0 ? 0. : this25 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								pixelShape.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								pixelShape.image[location1] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pixelimageXY_algo_HitTri(dx,dy,cx,cy,ax,ay,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft1;
			var softAB = softAB1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this1 = i;
						r = this1;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this2 = i1;
						g = this2;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this3 = i2;
						b = this3;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this4 = i3;
							a = this4;
							var location = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
							if(pixelShape.transparent && a < 254) {
								var this5 = pixelShape.image[location];
								var this6 = this5;
								var old = pixelimageXY_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this7 = old >> 24 & 255;
								var a1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = old >> 16 & 255;
								var r1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 8 & 255;
								var g1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old & 255;
								var b1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = rhs >> 24 & 255;
								var a2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 16 & 255;
								var r2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 8 & 255;
								var g2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs & 255;
								var b2 = this14 == 0 ? 0. : this14 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this15 = i4;
							a = this15;
							var location1 = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
							if(pixelShape.transparent && a < 254) {
								var this16 = pixelShape.image[location1];
								var this17 = this16;
								var old1 = pixelimageXY_Endian_isLittleEndian ? (this17 >> 24 & 255) << 24 | (this17 & 255) << 16 | (this17 >> 8 & 255) << 8 | this17 >> 16 & 255 : this17;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this18 = old1 >> 24 & 255;
								var a11 = this18 == 0 ? 0. : this18 / 255;
								var this19 = old1 >> 16 & 255;
								var r11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 8 & 255;
								var g11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 & 255;
								var b11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = rhs1 >> 24 & 255;
								var a21 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 16 & 255;
								var r21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 8 & 255;
								var g21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 & 255;
								var b21 = this25 == 0 ? 0. : this25 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								pixelShape.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								pixelShape.image[location1] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx,by,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft1;
			var softAB = softBC1;
			var softBC = softCD1;
			var softCA = false;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i = rA | 0;
						if(i > 255) {
							i = 255;
						}
						if(i < 0) {
							i = 0;
						}
						var this1 = i;
						r = this1;
						var i1 = gA | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this2 = i1;
						g = this2;
						var i2 = bA | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this3 = i2;
						b = this3;
						if(softAB == true && softBC == false && softCA == true) {
							min = ratioA < ratioC ? ratioA : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i3 = aA * soft3 * min | 0;
							if(i3 > 255) {
								i3 = 255;
							}
							if(i3 < 0) {
								i3 = 0;
							}
							var this4 = i3;
							a = this4;
							var location = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
							if(pixelShape.transparent && a < 254) {
								var this5 = pixelShape.image[location];
								var this6 = this5;
								var old = pixelimageXY_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
								var rhs = a << 24 | r << 16 | g << 8 | b;
								var this7 = old >> 24 & 255;
								var a1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = old >> 16 & 255;
								var r1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = old >> 8 & 255;
								var g1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = old & 255;
								var b1 = this10 == 0 ? 0. : this10 / 255;
								var this11 = rhs >> 24 & 255;
								var a2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = rhs >> 16 & 255;
								var r2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = rhs >> 8 & 255;
								var g2 = this13 == 0 ? 0. : this13 / 255;
								var this14 = rhs & 255;
								var b2 = this14 == 0 ? 0. : this14 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
								var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
								var a4 = 255 * (a3 + a2) | 0;
								var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						if(softAB == true && softBC == true && softCA == false) {
							min = ratioB < ratioC ? ratioB : ratioC;
							max = ratioA > ratioB ? ratioA : ratioB;
							if(!(max > ratioC)) {
								max = ratioC;
							}
							max = (1 - max) / 2;
							if(!(min < max)) {
								min = (max + min) / 2;
							}
							var i4 = aA * soft3 * min | 0;
							if(i4 > 255) {
								i4 = 255;
							}
							if(i4 < 0) {
								i4 = 0;
							}
							var this15 = i4;
							a = this15;
							var location1 = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
							if(pixelShape.transparent && a < 254) {
								var this16 = pixelShape.image[location1];
								var this17 = this16;
								var old1 = pixelimageXY_Endian_isLittleEndian ? (this17 >> 24 & 255) << 24 | (this17 & 255) << 16 | (this17 >> 8 & 255) << 8 | this17 >> 16 & 255 : this17;
								var rhs1 = a << 24 | r << 16 | g << 8 | b;
								var this18 = old1 >> 24 & 255;
								var a11 = this18 == 0 ? 0. : this18 / 255;
								var this19 = old1 >> 16 & 255;
								var r11 = this19 == 0 ? 0. : this19 / 255;
								var this20 = old1 >> 8 & 255;
								var g11 = this20 == 0 ? 0. : this20 / 255;
								var this21 = old1 & 255;
								var b11 = this21 == 0 ? 0. : this21 / 255;
								var this22 = rhs1 >> 24 & 255;
								var a21 = this22 == 0 ? 0. : this22 / 255;
								var this23 = rhs1 >> 16 & 255;
								var r21 = this23 == 0 ? 0. : this23 / 255;
								var this24 = rhs1 >> 8 & 255;
								var g21 = this24 == 0 ? 0. : this24 / 255;
								var this25 = rhs1 & 255;
								var b21 = this25 == 0 ? 0. : this25 / 255;
								var a31 = a11 * (1 - a21);
								var r4 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g4 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b4 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a5 = 255 * (a31 + a21) | 0;
								var blended1 = a5 << 24 | r4 << 16 | g4 << 8 | b4;
								pixelShape.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								pixelShape.image[location1] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
							}
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pixelimageXY_algo_HitTri(bx,by,cx,cy,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			if(hasHit == true) {
				var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
				tmp = v;
			} else {
				tmp = null;
			}
		} else {
			var ax = this.aX + this.offX;
			var ay = this.aY + this.offY;
			var bx = this.bX + this.offX;
			var by = this.bY + this.offY;
			var cx = this.cX + this.offX;
			var cy = this.cY + this.offY;
			var dx = this.dX + this.offX;
			var dy = this.dY + this.offY;
			var color = this.strokeColor;
			var soft = this.edgeSoft;
			var softAB = true;
			var softBC = true;
			var softCD = true;
			var softDA = true;
			if(softDA == null) {
				softDA = true;
			}
			if(softCD == null) {
				softCD = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft == null) {
				soft = 40;
			}
			var soft1 = soft;
			var softAB1 = softAB;
			var softBC1 = softBC;
			var softCD1 = softCD;
			var softDA1 = softDA;
			var hasHit = false;
			if(hasHit == null) {
				hasHit = false;
			}
			if(softDA1 == null) {
				softDA1 = true;
			}
			if(softCD1 == null) {
				softCD1 = true;
			}
			if(softBC1 == null) {
				softBC1 = true;
			}
			if(softAB1 == null) {
				softAB1 = true;
			}
			if(soft1 == null) {
				soft1 = 40;
			}
			var soft3 = soft1;
			var softAB = softAB1;
			var softBC = false;
			var softCA = softDA1;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(ax > bx) {
				if(ax > dx) {
					var ii_min = bx > dx ? Math.floor(dx) : Math.floor(bx);
					var ii_max = Math.ceil(ax);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(bx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(bx > dx) {
				var ii_min = ax > dx ? Math.floor(dx) : Math.ceil(ax);
				var ii_max = Math.ceil(bx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(ax);
				var ii_max = Math.ceil(dx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(ay > by) {
				if(ay > dy) {
					var ii_min = by > dy ? Math.floor(dy) : Math.floor(by);
					var ii_max = Math.ceil(ay);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(by);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(by > dy) {
				var ii_min = ay > dy ? Math.floor(dy) : Math.ceil(ay);
				var ii_max = Math.ceil(by);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(ay);
				var ii_max = Math.ceil(dy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						if(softAB) {
							if(softBC) {
								if(softCA) {
									var min1 = ratioA < ratioB ? ratioA : ratioB;
									if(!(min1 < ratioC)) {
										min1 = ratioC;
									}
									var max1 = ratioA > ratioB ? ratioA : ratioB;
									if(!(max1 > ratioC)) {
										max1 = ratioC;
									}
									max1 = (1 - max1) / 2;
									var min2 = min1 < max1 ? min1 : (max1 + min1) / 2;
									var i = aA * soft3 * min2 | 0;
									if(i > 255) {
										i = 255;
									}
									if(i < 0) {
										i = 0;
									}
									var this1 = i;
									a = this1;
								} else {
									min = ratioB < ratioC ? ratioB : ratioC;
									max = ratioA > ratioB ? ratioA : ratioB;
									if(!(max > ratioC)) {
										max = ratioC;
									}
									max = (1 - max) / 2;
									if(!(min < max)) {
										min = (max + min) / 2;
									}
									var i1 = aA * soft3 * min | 0;
									if(i1 > 255) {
										i1 = 255;
									}
									if(i1 < 0) {
										i1 = 0;
									}
									var this2 = i1;
									a = this2;
								}
							} else if(softCA) {
								min = ratioA < ratioC ? ratioA : ratioC;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i2 = aA * soft3 * min | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this3 = i2;
								a = this3;
							} else {
								min = ratioC;
								var i3 = aA * soft3 * min | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this4 = i3;
								a = this4;
							}
						} else if(softBC) {
							if(softCA) {
								min = ratioA < ratioB ? ratioA : ratioB;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i4 = aA * soft3 * min | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this5 = i4;
								a = this5;
							} else {
								min = ratioB;
								var i5 = aA * soft3 * min | 0;
								if(i5 > 255) {
									i5 = 255;
								}
								if(i5 < 0) {
									i5 = 0;
								}
								var this6 = i5;
								a = this6;
							}
						} else if(softCA) {
							min = ratioA;
							var i6 = aA * soft3 * min | 0;
							if(i6 > 255) {
								i6 = 255;
							}
							if(i6 < 0) {
								i6 = 0;
							}
							var this7 = i6;
							a = this7;
						} else {
							var i7 = aA | 0;
							if(i7 > 255) {
								i7 = 255;
							}
							if(i7 < 0) {
								i7 = 0;
							}
							var this8 = i7;
							a = this8;
						}
						var i8 = rA | 0;
						if(i8 > 255) {
							i8 = 255;
						}
						if(i8 < 0) {
							i8 = 0;
						}
						var this9 = i8;
						r = this9;
						var i9 = gA | 0;
						if(i9 > 255) {
							i9 = 255;
						}
						if(i9 < 0) {
							i9 = 0;
						}
						var this10 = i9;
						g = this10;
						var i10 = bA | 0;
						if(i10 > 255) {
							i10 = 255;
						}
						if(i10 < 0) {
							i10 = 0;
						}
						var this11 = i10;
						b = this11;
						var location = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
						if(pixelShape.transparent && a < 254) {
							var this12 = pixelShape.image[location];
							var this13 = this12;
							var old = pixelimageXY_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var rhs = a << 24 | r << 16 | g << 8 | b;
							var this14 = old >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = old >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = old >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = old & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = rhs >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = rhs >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = rhs >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = rhs & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
							var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
							var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
							var a4 = 255 * (a3 + a2) | 0;
							var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pixelimageXY_algo_HitTri(ax,ay,bx,by,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			var soft3 = soft1;
			var softAB = softBC1;
			var softBC = softCD1;
			var softCA = false;
			var hasHit1 = hasHit;
			if(hasHit1 == null) {
				hasHit1 = false;
			}
			if(softCA == null) {
				softCA = true;
			}
			if(softBC == null) {
				softBC = true;
			}
			if(softAB == null) {
				softAB = true;
			}
			if(soft3 == null) {
				soft3 = 40;
			}
			var aA = color >> 24 & 255;
			var rA = color >> 16 & 255;
			var gA = color >> 8 & 255;
			var bA = color & 255;
			var bcx = cx - dx;
			var bcy = cy - dy;
			var acx = bx - dx;
			var acy = by - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var xIter3;
			if(bx > cx) {
				if(bx > dx) {
					var ii_min = cx > dx ? Math.floor(dx) : Math.floor(cx);
					var ii_max = Math.ceil(bx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				} else {
					var ii_min = Math.floor(cx);
					var ii_max = Math.ceil(dx);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					xIter3 = this1;
				}
			} else if(cx > dx) {
				var ii_min = bx > dx ? Math.floor(dx) : Math.ceil(bx);
				var ii_max = Math.ceil(cx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			} else {
				var ii_min = Math.floor(bx);
				var ii_max = Math.ceil(dx);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				xIter3 = this1;
			}
			var yIter3;
			if(by > cy) {
				if(by > dy) {
					var ii_min = cy > dy ? Math.floor(dy) : Math.floor(cy);
					var ii_max = Math.ceil(by);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				} else {
					var ii_min = Math.floor(cy);
					var ii_max = Math.ceil(dy);
					var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
					yIter3 = this1;
				}
			} else if(cy > dy) {
				var ii_min = by > dy ? Math.floor(dy) : Math.ceil(by);
				var ii_max = Math.ceil(cy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			} else {
				var ii_min = Math.floor(by);
				var ii_max = Math.ceil(dy);
				var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
				yIter3 = this1;
			}
			var undoImage = null;
			var w = xIter3.max - xIter3.start + 1;
			var h = yIter3.max - yIter3.start + 1;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			undoImage = this2;
			var rectLeft = xIter3.start;
			var rectTop = yIter3.start;
			var rectRight = xIter3.max;
			var _g = rectTop;
			var _g1 = yIter3.max;
			while(_g < _g1) {
				var dy1 = _g++;
				var _g2 = rectLeft;
				var _g3 = rectRight;
				while(_g2 < _g3) {
					var dx1 = _g2++;
					var c = pixelShape.image[pixelShape.useVirtualPos ? (dy1 - pixelShape.virtualY) * pixelShape.width + dx1 - pixelShape.virtualX | 0 : dy1 * pixelShape.width + dx1 | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(pixelShape.useMask && pixelShape.mask != null) {
						var this1 = pixelShape.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy1 - this1.virtualY) * this1.width + dx1 - this1.virtualX | 0 : dy1 * this1.width + dx1 | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x = dx1 - rectLeft;
						var y = dy1 - rectTop;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
							var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
							var this11 = undoImage.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			var found = false;
			var min = 0;
			var max = 0;
			var a = 0;
			var r = 0;
			var g = 0;
			var b = 0;
			var _g_min = xIter3.start;
			var _g_max = xIter3.max;
			while(_g_min < _g_max) {
				var px = _g_min++;
				var pcx = px - dx;
				found = false;
				var _g_min1 = yIter3.start;
				var _g_max1 = yIter3.max;
				while(_g_min1 < _g_max1) {
					var py = _g_min1++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						if(softAB) {
							if(softBC) {
								if(softCA) {
									var min1 = ratioA < ratioB ? ratioA : ratioB;
									if(!(min1 < ratioC)) {
										min1 = ratioC;
									}
									var max1 = ratioA > ratioB ? ratioA : ratioB;
									if(!(max1 > ratioC)) {
										max1 = ratioC;
									}
									max1 = (1 - max1) / 2;
									var min2 = min1 < max1 ? min1 : (max1 + min1) / 2;
									var i = aA * soft3 * min2 | 0;
									if(i > 255) {
										i = 255;
									}
									if(i < 0) {
										i = 0;
									}
									var this1 = i;
									a = this1;
								} else {
									min = ratioB < ratioC ? ratioB : ratioC;
									max = ratioA > ratioB ? ratioA : ratioB;
									if(!(max > ratioC)) {
										max = ratioC;
									}
									max = (1 - max) / 2;
									if(!(min < max)) {
										min = (max + min) / 2;
									}
									var i1 = aA * soft3 * min | 0;
									if(i1 > 255) {
										i1 = 255;
									}
									if(i1 < 0) {
										i1 = 0;
									}
									var this2 = i1;
									a = this2;
								}
							} else if(softCA) {
								min = ratioA < ratioC ? ratioA : ratioC;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i2 = aA * soft3 * min | 0;
								if(i2 > 255) {
									i2 = 255;
								}
								if(i2 < 0) {
									i2 = 0;
								}
								var this3 = i2;
								a = this3;
							} else {
								min = ratioC;
								var i3 = aA * soft3 * min | 0;
								if(i3 > 255) {
									i3 = 255;
								}
								if(i3 < 0) {
									i3 = 0;
								}
								var this4 = i3;
								a = this4;
							}
						} else if(softBC) {
							if(softCA) {
								min = ratioA < ratioB ? ratioA : ratioB;
								max = ratioA > ratioB ? ratioA : ratioB;
								if(!(max > ratioC)) {
									max = ratioC;
								}
								max = (1 - max) / 2;
								if(!(min < max)) {
									min = (max + min) / 2;
								}
								var i4 = aA * soft3 * min | 0;
								if(i4 > 255) {
									i4 = 255;
								}
								if(i4 < 0) {
									i4 = 0;
								}
								var this5 = i4;
								a = this5;
							} else {
								min = ratioB;
								var i5 = aA * soft3 * min | 0;
								if(i5 > 255) {
									i5 = 255;
								}
								if(i5 < 0) {
									i5 = 0;
								}
								var this6 = i5;
								a = this6;
							}
						} else if(softCA) {
							min = ratioA;
							var i6 = aA * soft3 * min | 0;
							if(i6 > 255) {
								i6 = 255;
							}
							if(i6 < 0) {
								i6 = 0;
							}
							var this7 = i6;
							a = this7;
						} else {
							var i7 = aA | 0;
							if(i7 > 255) {
								i7 = 255;
							}
							if(i7 < 0) {
								i7 = 0;
							}
							var this8 = i7;
							a = this8;
						}
						var i8 = rA | 0;
						if(i8 > 255) {
							i8 = 255;
						}
						if(i8 < 0) {
							i8 = 0;
						}
						var this9 = i8;
						r = this9;
						var i9 = gA | 0;
						if(i9 > 255) {
							i9 = 255;
						}
						if(i9 < 0) {
							i9 = 0;
						}
						var this10 = i9;
						g = this10;
						var i10 = bA | 0;
						if(i10 > 255) {
							i10 = 255;
						}
						if(i10 < 0) {
							i10 = 0;
						}
						var this11 = i10;
						b = this11;
						var location = pixelShape.useVirtualPos ? (py - pixelShape.virtualY) * pixelShape.width + px - pixelShape.virtualX | 0 : py * pixelShape.width + px | 0;
						if(pixelShape.transparent && a < 254) {
							var this12 = pixelShape.image[location];
							var this13 = this12;
							var old = pixelimageXY_Endian_isLittleEndian ? (this13 >> 24 & 255) << 24 | (this13 & 255) << 16 | (this13 >> 8 & 255) << 8 | this13 >> 16 & 255 : this13;
							var rhs = a << 24 | r << 16 | g << 8 | b;
							var this14 = old >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = old >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = old >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = old & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = rhs >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = rhs >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = rhs >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = rhs & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
							var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
							var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
							var a4 = 255 * (a3 + a2) | 0;
							var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[location] = pixelShape.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
						}
						found = true;
					} else if(found) {
						break;
					}
				}
			}
			if(hasHit1 == false) {
				var v = new pixelimageXY_algo_HitTri(bx,by,cx,cy,dx,dy,true);
				v.undoImage = undoImage;
				v.undoX = xIter3.start;
				v.undoY = yIter3.start;
			}
			if(hasHit == true) {
				var v = new pixelimageXY_algo_HitQuad(ax,ay,bx,by,cx,cy,dx,dy,true);
				tmp = v;
			} else {
				tmp = null;
			}
		}
		this.hitObj = tmp;
		return pixelShape;
	}
	,__class__: pixelimageXY_triangleGML_QuadShape
});
var triangleGML_shape_form_RectangleForm_$ = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,rounded) {
	if(rounded == null) {
		rounded = false;
	}
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	triangleGML_FillForm.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.rounded = rounded;
};
triangleGML_shape_form_RectangleForm_$.__name__ = "triangleGML.shape.form.RectangleForm_";
triangleGML_shape_form_RectangleForm_$.__super__ = triangleGML_FillForm;
triangleGML_shape_form_RectangleForm_$.prototype = $extend(triangleGML_FillForm.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "rounded":
			this.rounded = StringTools.trim(value).toLowerCase() == "true";
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			triangleGML_FillForm.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: triangleGML_shape_form_RectangleForm_$
});
var pixelimageXY_triangleGML_RectangleForm = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,rounded) {
	triangleGML_shape_form_RectangleForm_$.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,rounded);
};
pixelimageXY_triangleGML_RectangleForm.__name__ = "pixelimageXY.triangleGML.RectangleForm";
pixelimageXY_triangleGML_RectangleForm.__super__ = triangleGML_shape_form_RectangleForm_$;
pixelimageXY_triangleGML_RectangleForm.prototype = $extend(triangleGML_shape_form_RectangleForm_$.prototype,{
	render: function(pixelShape) {
		if(this.rounded == false) {
			var w = Math.ceil(this.width);
			var h = Math.ceil(this.height);
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			var this1 = this2;
			var temp = this1;
			temp.transparent = false;
			var color = this.strokeColor;
			var p = 0;
			var xx = p;
			var q = 0;
			var maxX = this.width | 0;
			var maxY = this.height | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = this.strokeWidth;
			var y = this.strokeWidth;
			var color = this.fill;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + (this.width - 2 * this.strokeWidth) | 0;
			var maxY = y + (this.height - 2 * this.strokeWidth) | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = this.left + this.offX | 0;
			var y = this.top + this.offY | 0;
			var _g = 0;
			var _g1 = temp.height;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = 0;
				var _g3 = temp.width;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x1 = x + dx;
						var y1 = y + dy;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && pixelShape.transparent) {
							var location = pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0;
							var this11 = pixelShape.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			temp = null;
		} else {
			var w = Math.ceil(this.width);
			var h = Math.ceil(this.height);
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			var this1 = this2;
			var temp = this1;
			temp.transparent = false;
			var wid = this.width;
			var hi = this.height;
			var color = this.strokeColor;
			var dx = -1.;
			var dy = -1.;
			var fat = -1.;
			var tall = -1.;
			if(dx < 0.) {
				var smallest = hi < wid ? hi : wid;
				var goldenRatio = 1.61803398875;
				dx = smallest / (goldenRatio + 2);
			}
			if(dy < 0.) {
				dy = dx;
			}
			if(fat < 0.) {
				fat = wid - 2 * dx;
			}
			if(tall < 0.) {
				tall = hi - 2 * dy;
			}
			var rightRadius = wid - fat - dx;
			var bottomRadius = hi - tall - dy;
			var farX = dx + fat;
			var lowerY = dy + tall;
			var cx = dx;
			var cy = dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > dy ? dy : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy1 = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx1 = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy1 - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy1 * temp.width + dx1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy1 - this11.virtualY) * this11.width + dx1 - this11.virtualX | 0 : dy1 * this11.width + dx1 | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy1 - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x1 = _g_min++;
					sxx = sx * x1;
					txx = tx * x1;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y1 = _g_min1++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x = dx;
			var p = x | 0;
			var xx = p;
			var q = 0;
			var maxX = x + fat | 0;
			var maxY = dy | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var cy = dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > dy ? dy : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 3 * Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = farX * by - bx * cy + (bx * cy1 - cx * by) + (cx * cy - farX * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy1;
					cx = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx - farX * cy1;
				var sx = cy1 - cy;
				var sy = farX - cx;
				var t0 = farX * by - cy * bx;
				var tx = cy - by;
				var ty = bx - farX;
				var A = -by * cx + cy * (-bx + cx) + farX * (by - cy1) + bx * cy1;
				var xIter3;
				if(farX > bx) {
					if(farX > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(farX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx) {
					var ii_min2 = farX > cx ? Math.floor(cx) : Math.ceil(farX);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(farX);
					var ii_max3 = Math.ceil(cx);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy1 = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx1 = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy1 - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy1 * temp.width + dx1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy1 - this11.virtualY) * this11.width + dx1 - this11.virtualX | 0 : dy1 * this11.width + dx1 | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy1 - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x1 = _g_min++;
					sxx = sx * x1;
					txx = tx * x1;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y1 = _g_min1++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(farX,cy,bx,by,cx,cy1,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var y = dy;
			var p = 0;
			var xx = p;
			var q = y | 0;
			var maxX = wid | 0;
			var maxY = y + tall | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var cx = dx;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > bottomRadius ? bottomRadius : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * lowerY + (bx * cy - cx1 * by) + (cx1 * lowerY - cx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy;
					cx1 = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = lowerY * cx1 - cx * cy;
				var sx = cy - lowerY;
				var sy = cx - cx1;
				var t0 = cx * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - cx;
				var A = -by * cx1 + lowerY * (-bx + cx1) + cx * (by - cy) + bx * cy;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(lowerY > by) {
					if(lowerY > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(lowerY);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy) {
					var ii_min6 = lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(lowerY);
					var ii_max7 = Math.ceil(cy);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx1 = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy * temp.width + dx1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx1 - this11.virtualX | 0 : dy * this11.width + dx1 | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx1 - rectLeft;
								var y = dy - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x1 = _g_min++;
					sxx = sx * x1;
					txx = tx * x1;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y1 = _g_min1++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(cx,lowerY,bx,by,cx1,cy,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x = dx;
			var p = x | 0;
			var xx = p;
			var q = lowerY | 0;
			var maxX = x + fat | 0;
			var maxY = lowerY + bottomRadius | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > bottomRadius ? bottomRadius : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 0;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = farX * by - bx * lowerY + (bx * cy - cx * by) + (cx * lowerY - farX * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = lowerY * cx - farX * cy;
				var sx = cy - lowerY;
				var sy = farX - cx;
				var t0 = farX * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - farX;
				var A = -by * cx + lowerY * (-bx + cx) + farX * (by - cy) + bx * cy;
				var xIter3;
				if(farX > bx) {
					if(farX > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(farX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx) {
					var ii_min2 = farX > cx ? Math.floor(cx) : Math.ceil(farX);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(farX);
					var ii_max3 = Math.ceil(cx);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(lowerY > by) {
					if(lowerY > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(lowerY);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy) {
					var ii_min6 = lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(lowerY);
					var ii_max7 = Math.ceil(cy);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx - rectLeft;
								var y = dy - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x1 = _g_min++;
					sxx = sx * x1;
					txx = tx * x1;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y1 = _g_min1++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(farX,lowerY,bx,by,cx,cy,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x = this.strokeWidth;
			var y = this.strokeWidth;
			var wid = this.width - 2 * this.strokeWidth;
			var hi = this.height - 2 * this.strokeWidth;
			var color = this.fill;
			var dx = -1.;
			var dy = -1.;
			var fat = -1.;
			var tall = -1.;
			if(dx < 0.) {
				var smallest = hi < wid ? hi : wid;
				var goldenRatio = 1.61803398875;
				dx = smallest / (goldenRatio + 2);
			}
			if(dy < 0.) {
				dy = dx;
			}
			if(fat < 0.) {
				fat = wid - 2 * dx;
			}
			if(tall < 0.) {
				tall = hi - 2 * dy;
			}
			var rightRadius = wid - fat - dx;
			var bottomRadius = hi - tall - dy;
			var farX = x + dx + fat;
			var lowerY = y + dy + tall;
			var cx = x + dx;
			var cy = y + dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > dy ? dy : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy1 = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx1 = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy1 - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy1 * temp.width + dx1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy1 - this11.virtualY) * this11.width + dx1 - this11.virtualX | 0 : dy1 * this11.width + dx1 | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx1 - rectLeft;
								var y1 = dy1 - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y2 - temp.virtualY) * temp.width + x2 - temp.virtualX | 0 : y2 * temp.width + x2 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y2 - temp.virtualY) * temp.width + x2 - temp.virtualX | 0 : y2 * temp.width + x2 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(cx,cy,bx,by,cx1,cy1,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x1 = x + dx;
			var p = x1 | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x1 + fat | 0;
			var maxY = y + dy | 0;
			while(true) {
				var x1 = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : q * temp.width + x1 | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : q * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var cy = y + dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > dy ? dy : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 3 * Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy1 = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = farX * by - bx * cy + (bx * cy1 - cx * by) + (cx * cy - farX * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy1;
					cx = bx_;
					cy1 = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = cy * cx - farX * cy1;
				var sx = cy1 - cy;
				var sy = farX - cx;
				var t0 = farX * by - cy * bx;
				var tx = cy - by;
				var ty = bx - farX;
				var A = -by * cx + cy * (-bx + cx) + farX * (by - cy1) + bx * cy1;
				var xIter3;
				if(farX > bx) {
					if(farX > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(farX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx) {
					var ii_min2 = farX > cx ? Math.floor(cx) : Math.ceil(farX);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(farX);
					var ii_max3 = Math.ceil(cx);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(cy > by) {
					if(cy > cy1) {
						var ii_min4 = by > cy1 ? Math.floor(cy1) : Math.floor(by);
						var ii_max4 = Math.ceil(cy);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy1);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy1) {
					var ii_min6 = cy > cy1 ? Math.floor(cy1) : Math.ceil(cy);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(cy);
					var ii_max7 = Math.ceil(cy1);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy1 = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx1 = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy1 - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy1 * temp.width + dx1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy1 - this11.virtualY) * this11.width + dx1 - this11.virtualX | 0 : dy1 * this11.width + dx1 | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx1 - rectLeft;
								var y1 = dy1 - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y1 - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y1 * undoImage.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y2 = _g_min1++;
						s = s0 + sxx + sy * y2;
						t = t0 + txx + ty * y2;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y2 - temp.virtualY) * temp.width + x2 - temp.virtualX | 0 : y2 * temp.width + x2 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y2 - temp.virtualY) * temp.width + x2 - temp.virtualX | 0 : y2 * temp.width + x2 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(farX,cy,bx,by,cx,cy1,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var y1 = y + dy;
			var p = x | 0;
			var xx = p;
			var q = y1 | 0;
			var maxX = x + wid | 0;
			var maxY = y1 + tall | 0;
			while(true) {
				var x1 = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : q * temp.width + x1 | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : q * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var cx = x + dx;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > bottomRadius ? bottomRadius : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = cx * by - bx * lowerY + (bx * cy - cx1 * by) + (cx1 * lowerY - cx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy;
					cx1 = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = lowerY * cx1 - cx * cy;
				var sx = cy - lowerY;
				var sy = cx - cx1;
				var t0 = cx * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - cx;
				var A = -by * cx1 + lowerY * (-bx + cx1) + cx * (by - cy) + bx * cy;
				var xIter3;
				if(cx > bx) {
					if(cx > cx1) {
						var ii_min = bx > cx1 ? Math.floor(cx1) : Math.floor(bx);
						var ii_max = Math.ceil(cx);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx1);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx1) {
					var ii_min2 = cx > cx1 ? Math.floor(cx1) : Math.ceil(cx);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(cx);
					var ii_max3 = Math.ceil(cx1);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(lowerY > by) {
					if(lowerY > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(lowerY);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy) {
					var ii_min6 = lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(lowerY);
					var ii_max7 = Math.ceil(cy);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx1 = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx1 - temp.virtualX | 0 : dy * temp.width + dx1 | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx1 - this11.virtualX | 0 : dy * this11.width + dx1 | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x1 = dx1 - rectLeft;
								var y = dy - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y * undoImage.width + x1 | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x1 - undoImage.virtualX | 0 : y * undoImage.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x2 = _g_min++;
					sxx = sx * x2;
					txx = tx * x2;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y1 = _g_min1++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x2 - temp.virtualX | 0 : y1 * temp.width + x2 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x2 - temp.virtualX | 0 : y1 * temp.width + x2 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(cx,lowerY,bx,by,cx1,cy,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x1 = x + dx;
			var p = x1 | 0;
			var xx = p;
			var q = lowerY | 0;
			var maxX = x1 + fat | 0;
			var maxY = lowerY + bottomRadius | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimageXY_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > bottomRadius ? bottomRadius : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 0;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var hasHit = false;
				var hasUndo = false;
				if(hasUndo == null) {
					hasUndo = false;
				}
				if(hasHit == null) {
					hasHit = false;
				}
				var adjustWinding = farX * by - bx * lowerY + (bx * cy - cx * by) + (cx * lowerY - farX * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var hasHit1 = hasHit;
				var hasUndo1 = hasUndo;
				if(hasUndo1 == null) {
					hasUndo1 = false;
				}
				if(hasHit1 == null) {
					hasHit1 = false;
				}
				var s0 = lowerY * cx - farX * cy;
				var sx = cy - lowerY;
				var sy = farX - cx;
				var t0 = farX * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - farX;
				var A = -by * cx + lowerY * (-bx + cx) + farX * (by - cy) + bx * cy;
				var xIter3;
				if(farX > bx) {
					if(farX > cx) {
						var ii_min = bx > cx ? Math.floor(cx) : Math.floor(bx);
						var ii_max = Math.ceil(farX);
						var this1 = new pixelimageXY_iter_IntIterStart(ii_min,ii_max);
						xIter3 = this1;
					} else {
						var ii_min1 = Math.floor(bx);
						var ii_max1 = Math.ceil(cx);
						var this2 = new pixelimageXY_iter_IntIterStart(ii_min1,ii_max1);
						xIter3 = this2;
					}
				} else if(bx > cx) {
					var ii_min2 = farX > cx ? Math.floor(cx) : Math.ceil(farX);
					var ii_max2 = Math.ceil(bx);
					var this3 = new pixelimageXY_iter_IntIterStart(ii_min2,ii_max2);
					xIter3 = this3;
				} else {
					var ii_min3 = Math.floor(farX);
					var ii_max3 = Math.ceil(cx);
					var this4 = new pixelimageXY_iter_IntIterStart(ii_min3,ii_max3);
					xIter3 = this4;
				}
				var yIter3;
				if(lowerY > by) {
					if(lowerY > cy) {
						var ii_min4 = by > cy ? Math.floor(cy) : Math.floor(by);
						var ii_max4 = Math.ceil(lowerY);
						var this5 = new pixelimageXY_iter_IntIterStart(ii_min4,ii_max4);
						yIter3 = this5;
					} else {
						var ii_min5 = Math.floor(by);
						var ii_max5 = Math.ceil(cy);
						var this6 = new pixelimageXY_iter_IntIterStart(ii_min5,ii_max5);
						yIter3 = this6;
					}
				} else if(by > cy) {
					var ii_min6 = lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY);
					var ii_max6 = Math.ceil(by);
					var this7 = new pixelimageXY_iter_IntIterStart(ii_min6,ii_max6);
					yIter3 = this7;
				} else {
					var ii_min7 = Math.floor(lowerY);
					var ii_max7 = Math.ceil(cy);
					var this8 = new pixelimageXY_iter_IntIterStart(ii_min7,ii_max7);
					yIter3 = this8;
				}
				var undoImage = null;
				if(hasUndo1) {
					var w = xIter3.max - xIter3.start + 1;
					var h = yIter3.max - yIter3.start + 1;
					var this9 = new Uint32Array(w * h | 0);
					var this10 = new pixelimageXY_ImageStruct(w,h,this9);
					undoImage = this10;
					var rectLeft = xIter3.start;
					var rectTop = yIter3.start;
					var rectRight = xIter3.max;
					var _g2 = rectTop;
					var _g3 = yIter3.max;
					while(_g2 < _g3) {
						var dy = _g2++;
						var _g4 = rectLeft;
						var _g5 = rectRight;
						while(_g4 < _g5) {
							var dx = _g4++;
							var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
							var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							if(temp.useMask && temp.mask != null) {
								var this11 = temp.mask;
								var c1 = this11.image[this11.useVirtualPos ? (dy - this11.virtualY) * this11.width + dx - this11.virtualX | 0 : dy * this11.width + dx | 0];
								var this12 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
								var maskPixel = this12;
								var this13 = col;
								var this14 = this13;
								if(maskPixel == 0) {
									var this15 = this14;
									col = this15;
								} else {
									var this16 = maskPixel >> 24 & 255;
									var m0 = this16 == 0 ? 0. : this16 / 255;
									var this17 = maskPixel >> 16 & 255;
									var m1 = this17 == 0 ? 0. : this17 / 255;
									var this18 = maskPixel >> 8 & 255;
									var m2 = this18 == 0 ? 0. : this18 / 255;
									var this19 = maskPixel & 255;
									var m3 = this19 == 0 ? 0. : this19 / 255;
									var ch0 = (1. - m0) * (this14 >> 24 & 255) | 0;
									var ch1 = (1. - m1) * (this14 >> 16 & 255) | 0;
									var ch2 = (1. - m2) * (this14 >> 8 & 255) | 0;
									var ch3 = (1. - m3) * (this14 & 255) | 0;
									col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
								}
							}
							if(col != 0) {
								var x = dx - rectLeft;
								var y = dy - rectTop;
								var this20 = col;
								var c2 = this20;
								if((c2 >> 24 & 255) < 254 && undoImage.transparent) {
									var location = undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0;
									var this21 = undoImage.image[location];
									var this22 = this21;
									var this23 = pixelimageXY_Endian_isLittleEndian ? (this22 >> 24 & 255) << 24 | (this22 & 255) << 16 | (this22 >> 8 & 255) << 8 | this22 >> 16 & 255 : this22;
									var this24 = this23 >> 24 & 255;
									var a1 = this24 == 0 ? 0. : this24 / 255;
									var this25 = this23 >> 16 & 255;
									var r1 = this25 == 0 ? 0. : this25 / 255;
									var this26 = this23 >> 8 & 255;
									var g1 = this26 == 0 ? 0. : this26 / 255;
									var this27 = this23 & 255;
									var b1 = this27 == 0 ? 0. : this27 / 255;
									var this28 = col >> 24 & 255;
									var a2 = this28 == 0 ? 0. : this28 / 255;
									var this29 = col >> 16 & 255;
									var r2 = this29 == 0 ? 0. : this29 / 255;
									var this30 = col >> 8 & 255;
									var g2 = this30 == 0 ? 0. : this30 / 255;
									var this31 = col & 255;
									var b2 = this31 == 0 ? 0. : this31 / 255;
									var a3 = a1 * (1 - a2);
									var r = 255 * (r1 * a3 + r2 * a2) | 0;
									var g = 255 * (g1 * a3 + g2 * a2) | 0;
									var b = 255 * (b1 * a3 + b2 * a2) | 0;
									var a = 255 * (a3 + a2) | 0;
									var blended = a << 24 | r << 16 | g << 8 | b;
									undoImage.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
								} else {
									undoImage.image[undoImage.useVirtualPos ? (y - undoImage.virtualY) * undoImage.width + x - undoImage.virtualX | 0 : y * undoImage.width + x | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
								}
							}
						}
					}
				}
				var found = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g_min = xIter3.start;
				var _g_max = xIter3.max;
				while(_g_min < _g_max) {
					var x1 = _g_min++;
					sxx = sx * x1;
					txx = tx * x1;
					found = false;
					var _g_min1 = yIter3.start;
					var _g_max1 = yIter3.max;
					while(_g_min1 < _g_max1) {
						var y1 = _g_min1++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(found) {
								break;
							}
						} else if(s + t < A) {
							var this32 = color;
							var c3 = this32;
							if((c3 >> 24 & 255) < 254 && temp.transparent) {
								var location1 = temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0;
								var this33 = temp.image[location1];
								var this34 = this33;
								var this35 = pixelimageXY_Endian_isLittleEndian ? (this34 >> 24 & 255) << 24 | (this34 & 255) << 16 | (this34 >> 8 & 255) << 8 | this34 >> 16 & 255 : this34;
								var this36 = this35 >> 24 & 255;
								var a11 = this36 == 0 ? 0. : this36 / 255;
								var this37 = this35 >> 16 & 255;
								var r11 = this37 == 0 ? 0. : this37 / 255;
								var this38 = this35 >> 8 & 255;
								var g11 = this38 == 0 ? 0. : this38 / 255;
								var this39 = this35 & 255;
								var b11 = this39 == 0 ? 0. : this39 / 255;
								var this40 = color >> 24 & 255;
								var a21 = this40 == 0 ? 0. : this40 / 255;
								var this41 = color >> 16 & 255;
								var r21 = this41 == 0 ? 0. : this41 / 255;
								var this42 = color >> 8 & 255;
								var g21 = this42 == 0 ? 0. : this42 / 255;
								var this43 = color & 255;
								var b21 = this43 == 0 ? 0. : this43 / 255;
								var a31 = a11 * (1 - a21);
								var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
								var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
								var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
								var a4 = 255 * (a31 + a21) | 0;
								var blended1 = a4 << 24 | r3 << 16 | g3 << 8 | b3;
								temp.image[location1] = pixelimageXY_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
							} else {
								temp.image[temp.useVirtualPos ? (y1 - temp.virtualY) * temp.width + x1 - temp.virtualX | 0 : y1 * temp.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
							}
							found = true;
						} else if(found) {
							break;
						}
					}
				}
				if(hasHit1 == true) {
					var v = new pixelimageXY_algo_HitTri(farX,lowerY,bx,by,cx,cy,true);
					if(hasUndo1) {
						v.undoImage = undoImage;
						v.undoX = xIter3.start;
						v.undoY = yIter3.start;
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x = this.left + this.offX | 0;
			var y = this.top + this.offY | 0;
			var _g = 0;
			var _g1 = temp.height;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = 0;
				var _g3 = temp.width;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
					var col = pixelimageXY_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimageXY_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x1 = x + dx;
						var y1 = y + dy;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && pixelShape.transparent) {
							var location = pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0;
							var this11 = pixelShape.image[location];
							var this12 = this11;
							var this13 = pixelimageXY_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelShape.image[location] = pixelimageXY_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelShape.image[pixelShape.useVirtualPos ? (y1 - pixelShape.virtualY) * pixelShape.width + x1 - pixelShape.virtualX | 0 : y1 * pixelShape.width + x1 | 0] = pixelimageXY_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			temp = null;
		}
		return pixelShape;
	}
	,__class__: pixelimageXY_triangleGML_RectangleForm
});
var pixelimageXY_triangleGML_ShapeAtt = function(shape,att) {
	this.shape = shape;
	this.att = att;
};
pixelimageXY_triangleGML_ShapeAtt.__name__ = "pixelimageXY.triangleGML.ShapeAtt";
pixelimageXY_triangleGML_ShapeAtt.prototype = {
	__class__: pixelimageXY_triangleGML_ShapeAtt
};
var triangleGML_TriangleGML_$ = function(drawTool,xml,x,y) {
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.imageResource = new haxe_ds_StringMap();
	this.drawTool = drawTool;
	if(xml != null) {
		this.xml = xml;
		this.offX = x;
		this.offY = y;
		this.process();
	}
};
triangleGML_TriangleGML_$.__name__ = "triangleGML.TriangleGML_";
triangleGML_TriangleGML_$.prototype = {
	addShape: function(str,x,y) {
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.xml = Xml.parse("<node>" + str + "</node>").firstElement();
		this.offX = x;
		this.offY = y;
		this.process();
		return this;
	}
	,process: function() {
		var e = this.xml.elements();
		while(e.hasNext()) {
			var e1 = e.next();
			this.processShape(e1);
		}
	}
	,processShape: function(x) {
		if(x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		var name = x.nodeName;
		var s = this.getTriangleGML(name);
		var att = x.attributes();
		while(att.hasNext()) {
			var att1 = att.next();
			this.processAttribute(att1,x.get(att1),s);
		}
		if(this.offX != 0. || this.offY != 0.) {
			s.translate(this.offX,this.offY);
		}
		if(this.shapes == null) {
			this.shapes = [];
		}
		this.shapes.push(s);
	}
	,processAttribute: function(att,value,shape) {
		haxe_Log.trace(att + " " + value,{ fileName : "triangleGML/TriangleGML_.hx", lineNumber : 60, className : "triangleGML.TriangleGML_", methodName : "processAttribute"});
		if(HxOverrides.substr(att,0,"image".length) == "image") {
			shape.setImage(att,this.imageResource.h[value.toLowerCase()]);
		} else {
			shape.setParameter(att,value);
		}
	}
	,render: function() {
		var _g = 0;
		var _g1 = this.shapes.length;
		while(_g < _g1) {
			var i = _g++;
			this.shapes[i].render(this.drawTool);
		}
	}
	,__class__: triangleGML_TriangleGML_$
};
var pixelimageXY_triangleGML_TriangleGML = function(drawTool,xml,x,y) {
	this.shapes_att = [];
	this.promises = [];
	triangleGML_TriangleGML_$.call(this,drawTool,xml,x,y);
};
pixelimageXY_triangleGML_TriangleGML.__name__ = "pixelimageXY.triangleGML.TriangleGML";
pixelimageXY_triangleGML_TriangleGML.load = function(url) {
	return new Promise(function(resolve,reject) {
		var image = new Image();
		image.onload = function() {
			var resolve1 = resolve;
			var canvas = window.document.createElement("canvas");
			canvas.width = image.width;
			canvas.height = image.height;
			canvas.getContext("2d",null).drawImage(image,0,0,image.width,image.height);
			var w = image.width;
			var h = image.height;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			var pixelImage = this2;
			pixelImage.transparent = false;
			var ctx = canvas.getContext("2d",null);
			var imageData = pixelImage.useVirtualPos ? ctx.getImageData(pixelImage.virtualX,pixelImage.virtualY,pixelImage.width,pixelImage.height) : ctx.getImageData(0,0,pixelImage.width,pixelImage.height);
			var data = imageData.data;
			var temp = new Uint32Array(data.buffer);
			pixelImage.image = temp;
			canvas = null;
			resolve1(pixelImage);
		};
		image.src = url;
	});
};
pixelimageXY_triangleGML_TriangleGML.__super__ = triangleGML_TriangleGML_$;
pixelimageXY_triangleGML_TriangleGML.prototype = $extend(triangleGML_TriangleGML_$.prototype,{
	processAttribute: function(att,value,shape) {
		if(HxOverrides.substr(att,0,"src".length) == "src") {
			this.promises.push(pixelimageXY_triangleGML_TriangleGML.load(value));
			this.shapes_att.push(new pixelimageXY_triangleGML_ShapeAtt(shape,att.toLowerCase()));
		} else {
			triangleGML_TriangleGML_$.prototype.processAttribute.call(this,att,value,shape);
		}
	}
	,renderPromise: function() {
		var here = this;
		if(this.promises.length == 0) {
			return Promise.all([Promise.resolve()]).then(function(_) {
				here.render();
				here = null;
				return here;
			});
		} else {
			return Promise.all(this.promises).then(function(pixelimages) {
				var _g = 0;
				var _g1 = pixelimages.length;
				while(_g < _g1) {
					var i = _g++;
					var shapeAt = here.shapes_att[i];
					var pixelShape = pixelimages[i];
					shapeAt.shape.setImage(shapeAt.att,pixelShape);
				}
				here.render();
				here = null;
				return here;
			});
		}
	}
	,getTriangleGML: function(nodeName) {
		var s;
		switch(nodeName) {
		case "ArcForm":
			s = new pixelimageXY_triangleGML_ArcForm();
			break;
		case "ArrowShape":
			s = new pixelimageXY_triangleGML_ArrowShape();
			break;
		case "CircleForm":
			s = new pixelimageXY_triangleGML_CircleForm();
			break;
		case "EllipseForm":
			s = new pixelimageXY_triangleGML_EllipseForm();
			break;
		case "LineGridShape":
			s = new pixelimageXY_triangleGML_LineGridShape();
			break;
		case "LineShape":
			s = new pixelimageXY_triangleGML_LineShape();
			break;
		case "NineSlicePicture":
			s = new pixelimageXY_triangleGML_NineSlicePicture();
			break;
		case "QuadShape":
			s = new pixelimageXY_triangleGML_QuadShape();
			break;
		case "RectangleForm":
			s = new pixelimageXY_triangleGML_RectangleForm();
			break;
		default:
			throw haxe_Exception.thrown("shape unfound");
		}
		return s;
	}
	,__class__: pixelimageXY_triangleGML_TriangleGML
});
var pixelimage_$samples_pixelimage_$canvas_Arcs = function() {
	this.arcChord2 = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFFFF7700\" strokeWidth=\"12\" \n        fill=\"0xFF00A6FF\" \n        startAngle=\"190\" sweepAngle=\"90\"\n        arcType=\"chord\">\n    </ArcForm>";
	this.arcEllipse2 = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFF0000FF\" strokeWidth=\"12\" \n        fill=\"0xFFFF00EE\" \n        startAngle=\"-43\" sweepAngle=\"108\"\n        arcType=\"ellipse\">\n    </ArcForm>";
	this.arcPie2 = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFFFF0000\" strokeWidth=\"12\" \n        fill=\"0xFF00FF00\" \n        startAngle=\"120\" sweepAngle=\"70\"\n        arcType=\"pie\">\n    </ArcForm>";
	this.arcChord = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFFFF7700\" strokeWidth=\"12\" \n        fill=\"0xFF00A6FF\" \n        startAngle=\"0\" sweepAngle=\"240\"\n        arcType=\"chord\">\n    </ArcForm>";
	this.arcEllipse = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFF0000FF\" strokeWidth=\"12\" \n        fill=\"0xFFFF00EE\" \n        startAngle=\"0\" sweepAngle=\"240\"\n        arcType=\"ellipse\">\n    </ArcForm>";
	this.arcPie = "<ArcForm \n        left=\"100\"  top=\"100\" \n        width=\"500\" height=\"480\" \n        strokeColor=\"0xFFFF0000\" strokeWidth=\"12\" \n        fill=\"0xFF00FF00\" \n        startAngle=\"0\" sweepAngle=\"240\"\n        arcType=\"pie\">\n    </ArcForm>";
	this.aGrid = "<LineGridShape\n        left = \"100\"  top = \"100\"\n        width = \"2048\" height = \"1536\"\n        delta = \"100\" deltaH = \"100\"\n        strokeColor=\"0xfF003300\" strokeWidth=\"3\">\n    </LineGridShape>";
	this.backGround = "<RectangleForm\n        left = \"-1\"\n        top = \"-1\"\n        width = \"3073\"\n        height = \"2305\"\n        fill = \"0xFF000203\">\n    </RectangleForm>";
	this.canvasSetup = new htmlHelper_canvas_CanvasSetup();
	var surface = this.canvasSetup.surface;
	var this1 = new Uint32Array(12582912);
	var this2 = new pixelimageXY_ImageStruct(4096,3072,this1);
	var this1 = this2;
	var pixelShape = this1;
	pixelShape.transparent = true;
	var parser = new pixelimageXY_triangleGML_TriangleGML(pixelShape);
	parser.addShape(this.backGround,10,10);
	parser.addShape(this.aGrid,10,10);
	parser.addShape(this.arcPie,10,0);
	parser.addShape(this.arcEllipse,10,500);
	parser.addShape(this.arcChord,10,1000);
	parser.addShape(this.arcPie2,1210,0);
	parser.addShape(this.arcEllipse2,1210,500);
	parser.addShape(this.arcChord2,1210,1000);
	parser.renderPromise().then(function(_) {
		var ctx = surface.me;
		if(pixelShape.useMask && pixelShape.mask != null) {
			var w = pixelShape.width;
			var h = pixelShape.height;
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimageXY_ImageStruct(w,h,this1);
			var temp = this2;
			var _g = 0;
			var _g1 = pixelShape.image.length;
			while(_g < _g1) {
				var i = _g++;
				var this1 = pixelShape.image[i];
				var p0 = this1;
				var this2 = pixelShape.mask.image[i];
				var m1 = this2;
				var value;
				if(m1 == 0) {
					var this3 = p0;
					value = this3;
				} else {
					var this4 = m1 >> 24 & 255;
					var m0 = this4 == 0 ? 0. : this4 / 255;
					var this5 = m1 >> 16 & 255;
					var m11 = this5 == 0 ? 0. : this5 / 255;
					var this6 = m1 >> 8 & 255;
					var m2 = this6 == 0 ? 0. : this6 / 255;
					var this7 = m1 & 255;
					var m3 = this7 == 0 ? 0. : this7 / 255;
					var ch0 = (1. - m0) * (p0 >> 24 & 255) | 0;
					var ch1 = (1. - m11) * (p0 >> 16 & 255) | 0;
					var ch2 = (1. - m2) * (p0 >> 8 & 255) | 0;
					var ch3 = (1. - m3) * (p0 & 255) | 0;
					value = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
				}
				temp.image[i] = value;
			}
			var dataimg = temp.image;
			var data = new Uint8ClampedArray(new Uint8Array(dataimg.buffer).buffer);
			var imageData = new ImageData(data,pixelShape.width,pixelShape.height);
			if(pixelShape.useVirtualPos) {
				ctx.putImageData(imageData,0 - pixelShape.virtualX,0 - pixelShape.virtualY);
			} else {
				ctx.putImageData(imageData,0,0);
			}
		} else {
			var dataimg = pixelShape.image;
			var data = new Uint8ClampedArray(new Uint8Array(dataimg.buffer).buffer);
			var imageData = new ImageData(data,pixelShape.width,pixelShape.height);
			if(pixelShape.useVirtualPos) {
				ctx.putImageData(imageData,0 - pixelShape.virtualX,0 - pixelShape.virtualY);
			} else {
				ctx.putImageData(imageData,0,0);
			}
		}
	});
};
pixelimage_$samples_pixelimage_$canvas_Arcs.__name__ = "pixelimage_samples.pixelimage_canvas.Arcs";
pixelimage_$samples_pixelimage_$canvas_Arcs.prototype = {
	__class__: pixelimage_$samples_pixelimage_$canvas_Arcs
};
function pixelimage_$samples_pixelimage_$canvas_Arcs_main() {
	new pixelimage_$samples_pixelimage_$canvas_Arcs();
}
var triangleGML_hitTest_IhitObj = function() { };
triangleGML_hitTest_IhitObj.__name__ = "triangleGML.hitTest.IhitObj";
triangleGML_hitTest_IhitObj.__isInterface__ = true;
var vision_ds_Line2D = function(start,end) {
	this.end = new vision_ds_Point2D(0,0);
	this.start = new vision_ds_Point2D(0,0);
	this.start.x = start.x;
	this.start.y = start.y;
	this.end.x = end.x;
	this.end.y = end.y;
	var x = end.x - start.x;
	var y = end.y - start.y;
	this.radians = Math.atan2(x,y);
	this.slope = Math.tan(this.radians);
	this.degrees = this.radians * 180 / Math.PI;
};
vision_ds_Line2D.__name__ = "vision.ds.Line2D";
vision_ds_Line2D.prototype = {
	toString: function() {
		return "\n (" + Std.string(this.start) + ".x, " + Std.string(this.start) + ".y) --> (" + Std.string(this.end) + ".x, " + Std.string(this.end) + ".y)";
	}
	,__class__: vision_ds_Line2D
};
var vision_ds_Point2D = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
vision_ds_Point2D.__name__ = "vision.ds.Point2D";
vision_ds_Point2D.prototype = {
	toString: function() {
		return "(" + this.x + ", " + this.y + ")";
	}
	,__class__: vision_ds_Point2D
};
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false});
String.__name__ = "String";
Array.__name__ = "Array";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	var h = new haxe_ds_StringMap();
	h.h["lt"] = "<";
	h.h["gt"] = ">";
	h.h["amp"] = "&";
	h.h["quot"] = "\"";
	h.h["apos"] = "'";
	$r = h;
	return $r;
}(this));
var pixelimageXY_Endian_isLittleEndian = (function($this) {
	var $r;
	var a8 = new Uint8Array(4);
	var a32 = new Uint32Array(a8.buffer)[0] = -3407855;
	$r = a8[0] != 255;
	return $r;
}(this));
pixelimage_$samples_pixelimage_$canvas_Arcs_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
